# HTML5

```
https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5
```

### 语义化标签类

+ 什么是标签语义化
  + 合理的标签干合适的事情

+ 都有哪些标签，都是啥意思
  + 块级（display：block）：div 、p、h1~h6、hr、ul、ol、li、dl、dd、form、table、header、footer、main、nav、sector、arcitcle、pre、table、tbody、thead、th、tr、tfoot
  +  行级（display：inline）：a、span、small、strong、em、i、code、
  + 行内块（display：inline-block）：img、input

+ **区别**：
  + 1.行内元素与块级函数可以相互转换，通过修改display属性值来切换块级元素和行内元素，行内元素display：inline，块级元素display：block。
  + 2.行内元素和其他行内元素都会在一条水平线上排列，都是在同一行的；块级元素却总是会在新的一行开始排列，各个块级元素独占一行，垂直向下排列，若想使其水平方向排序，可使用左右浮动（float：left/right）让其水平方向排列。
  + 3.行内元素不可以设置宽高，宽度高度随文本内容的变化而变化，但是可以设置行高（line-height），同时在设置外边距margin上下无效，左右有效，内填充padding上下无效，左右有效；块级元素可以设置宽高，并且宽度高度以及外边距，内填充都可随意控制。
  + 4.块级元素可以包含行内元素和块级元素，还可以容纳[内联元素](https://www.baidu.com/s?wd=内联元素&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)和其他元素；行内元素不能包含块级元素，只能容纳文本或者其他行内元素。

+ 如何转换
  + display还有none（隐藏dom）、flex（弹性）、table（表）

+ diplay的值都有啥
  + display：none和visibility：hidden、ocpacity：0（兼容用fliter
  + filter滤镜：对比度、饱和度、阴影、色相、透明度
+ display:none
  + 让元素如何隐藏，你可以怎么做？
  + display:none和visibility:hidden的区别
  + opacity的兼容处理
  + filter还能做哪些事情

+ display：flex 响应式、兼容性
  + 项目中你什么时候用到了flex
  + 除了这种方式能居中还有哪些
  + 响应式布局还可以怎么做
  + 都有哪些盒子模型

### 音频处理

### canvas/webGL

### history API

### requestAnimationFrame

### 地理位置

### web scoket

# CSS3

### 盒子水平垂直居中的五大方案

+ 项目中经常遇到这种需求，最开始xxx，喜欢用flex，后来发现xxx，在xx博客上突然发现xx更好，xx解决了兼容性（拒绝背书式）

#### 定位：三种

```
.father{
	position: relative;
}
```

+ （1）定位1：需要知道元素的宽高

  ```
  .box{
  	position: absolute;
  	top: 50%;
  	left: 50%;
  	margin-top: -1/2height;
  	margin-left: - 1/2width;
  }
  ```

+ （2）定位2：需要有元素宽高限定

  ```
  .box{
  		position: absolute;
  		top: 0;
  		left: 0;
  		right: 0;
  		bottom: 0;
  		margin:auto;
  }
  ```

+ （3）定位3：不需要父有具体宽高限制（兼容性不如上边Ie9+）

  + 可以用transform相对于本体宽高的百分比移动

  ```
  .box{
  		position: absolute;
  		top: 50%;
  		left: 50%;
  		transform: translate(-50%, -50%)
  }
  ```

#### display: flex

+ display:flex（ie10+）

  ```
  .father{
  	display:flex;
  	justify-content: center;
  	align-items: cneter;
  }
  ```

#### JavaScript

+ js实现就是模拟css写样式

  ```
  let HTML = document.documentELement,
  		winW = HTML.clientWidth,
  		winH = HTML.clientHeight,
  		boxW = box.offsetWidth,
  		boxH = box.offsetHeight;
  box.style.position = 'absolute';
  box.style.left = (winW - boxW) / 2 + 'px';
  box.style.top = (winH - boxH)/ 2 + 'px'
  ```

+ `**Element.getBoundingClientRect()**` 方法返回元素的大小及其相对于视口的位置。

#### display: table-cell

```
.father{
	display: table-cell;
	vertical-align: middle;
	text-align: center;
	// 宽高不能是百分比,固定宽高
	width: 500px;
	height: 500px;
}
.box{
	display:inline-block;
}
```

### 常规

### 盒子模型

#### 标准盒模型（content-box）

+ box-sizing: content-box
+ width/height=content、padding、border

#### ie怪异盒模型（border-box）

+ box-sizing: border-box
+ 怪异盒模型的好处，固定到border控制宽高，不用重新计算padding和border

#### flex弹性伸缩盒模型

+ 盒子设置display：flex。
+ main axis X轴
+ cross axis Y轴

#### column多列盒模型

+ column-count

### 几大经典布局方案

+ 左右固定，中间自适应

#### 圣杯

+ 

```
<style>
	html,body{
		height:100&;
		overflow: hindden;
	}
	.container{
		height: 100%;
		padding: 0 200px;
	}
	.left,.right{
		width:200px;
		min-height:200px;
		backgorund: lightblue;
	}
	.center{
		width:100%;
		min-height: 400px;
	}
	.left,.center,.right{
		float:left;
	}
	.left{
		margin-left: -100%;
		position: relative;
		left: -200px;
	}
	.right{
		margin-right: -200px;
	}
</style>
<html>
<body>
	<div class="container clearfix">
		<div class="center"></div>
		<div class="left"></div>
		<div class="right"></div>
	</div>
</body>
</html>
```

#### 双飞翼布局

```
<style>
	html,body{
		height:100&;
		overflow: hindden;
	}
	.container{
		height: 100%;
	}
	.left,.right{
		width:200px;
		min-height:200px;
		backgorund: lightblue;
	}
	.container .center{
		margin: 0 200px;
		min-height: 400px;
	}
	.left,.container,.right{
		float:left;
	}
	.left{
		margin-left: -100%;
	}
	.right{
		margin-right: -200px;
	} 
</style>
<html>
<body class="clearfix">
	<div class="container">
		<div class="center"></div>
	</div>
	<div class="left"></div>
	<div class="right"></div>
</body>
</html>
```

#### 使用CALC

```
// 兼容到IE9
.center{
	width: calc(100% - 400px);
	min-height:400px;
}
```

#### flex布局

```
<style>
	html,body{
		height:100&;
		overflow: hindden;
	}
	.container{
		display: flex;
		justify-content: space-between;
		flex:1;
	}
	.center{
		flex:1;	// 自动分配剩余空间全部
		min-height: 400px;
	}
	 .left,.right{
      height:200px;
      background:blue;
      flex:0 0 200px;/* 左右两列固定宽 */ // 放大，缩小，占宽度
    }
    .left{
   	 	order:-1;/* 让left居于左侧 */
    }
</style>
<html>
<body>
	<div class="container">
		<div class="left"></div>
		<div class="center"></div>
		<div class="right"></div>
	</div>
</body>
</html>
```

#### 定位

### flex详解

+ Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。
+ 设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。
+ 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。
+ 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。
+ 项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。

#### 容器属性

##### flex-direction属性

+ `flex-direction`属性决定主轴的方向（即项目的排列方向）。

  ```
  .box {
    flex-direction: row | row-reverse | column | column-reverse;
  }
  ```

+ `row`（默认值）：主轴为水平方向，起点在左端。
+ `row-reverse`：主轴为水平方向，起点在右端。
+ `column`：主轴为垂直方向，起点在上沿。
+ `column-reverse`：主轴为垂直方向，起点在下沿。

##### flex-wrap属性

+ 默认情况下，项目都排在一条线（又称"轴线"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。

  ```
  .box{
    flex-wrap: nowrap | wrap | wrap-reverse;
  }
  ```

+ （1）`nowrap`（默认）：不换行。

+ （2）`wrap`：换行，第一行在上方。

+ （3）`wrap-reverse`：换行，第一行在下方。

##### flex-flow

+ `flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。

  ```
  .box {
    flex-flow: <flex-direction> || <flex-wrap>;
  }
  ```

##### justify-content属性

+ `justify-content`属性定义了项目在主轴上的对齐方式。

  ```
  .box {
    justify-content: flex-start | flex-end | center | space-between | space-around;
  }
  ```

+ `flex-start`（默认值）：左对齐
+ `flex-end`：右对齐
+ `center`： 居中
+ `space-between`：两端对齐，项目之间的间隔都相等。
+ `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

##### align-items属性

+ `align-items`属性定义项目在交叉轴上如何对齐。

  ```
  .box {
    align-items: flex-start | flex-end | center | baseline | stretch;
  }
  ```

+ `flex-start`：交叉轴的起点对齐。
+ `flex-end`：交叉轴的终点对齐。
+ `center`：交叉轴的中点对齐。
+ `baseline`: 项目的第一行文字的基线对齐。
+ `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

##### align-content属性

+ `align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

````
.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
````

+ `flex-start`：与交叉轴的起点对齐。
+ `flex-end`：与交叉轴的终点对齐。
+ `center`：与交叉轴的中点对齐。
+ `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。
+ `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
+ `stretch`（默认值）：轴线占满整个交叉轴。

### 项目的属性

##### order属性

+ `order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。

  ```
  .item {
    order: <integer>;
  }
  ```

##### flex-grow属性

+ `flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。

  ```
  .item {
    flex-grow: <number>; /* default 0 */
  }
  ```

+ 如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

##### flex-shrink属性

+ `flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

  ```
  .item {
    flex-shrink: <number>; /* default 1 */
  }
  ```

+ 如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。
+ 负值对该属性无效。

##### flex-basis属性

+ `flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。

  ```
  .item {
    flex-basis: <length> | auto; /* default auto */
  }
  ```

##### flex属性

+ `flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。

  ```
  .item {
    flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
  }
  ```

+ 该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。
+ 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

##### align-self属性

+ `align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

  ```
  .item {
    align-self: auto | flex-start | flex-end | center | baseline | stretch;
  }
  ```

+ 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。

### 响应式布局

#### 移动端响应式布局开发的三大方案

##### media

+ 媒体查询（一套）

##### rem

+ （应用于两套 中的移动端）

##### flex

##### vh/vw

+ 百分比布局

###  动画

# js

## 堆栈内存及闭包作用域

### JS的数据类型

#### 基本数据类型

+ boolean
+ null
+ undefined
+ number
+ string
+ symbol
+ bigint

+ 举例：Symbol的作用

#### BigInt

##### 什么是BigInt

+ BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对`大整数`执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

##### 为什么需要BigInt

+ JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。

##### 如何创建并使用BigInt？

+ 要创建BigInt，只需要在数字末尾追加n即可。

  ```
  console.log( 9007199254740995n );    // → 9007199254740995n	
  console.log( 9007199254740995 );     // → 9007199254740996
  ```

+ 另一种创建BigInt的方法是用BigInt()构造函数

  ```
  BigInt("9007199254740995");    // → 9007199254740995n
  ```

##### 值得警惕的点

+ BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。
+ 因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。
+ 不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。
+ 当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。
+ 元素都为BigInt的数组可以进行sort。
+ BigInt可以正常地进行位运算，如|、&、<<、>>和^

##### 浏览器兼容性

+ 其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现，要正式成为规范，其实还有很长的路要走。

####  引用数据类型

+  对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）
+ 引用类型是为了让内存公用空间

#### 基本包装类型

+ 基本数据类型，包括Boolean, Number和String。

+ 装箱

  + 第一步:创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。
  + 第二步: 调用实例方法。
  + 第三步: 执行完方法立即销毁这个实例。

  ```
  （1）创建String类型的一个实例；
  （2）在实例上调用指定的方法；
  （3）销毁这个实例；
  '1'.toString() // =>
  var s = new Object('1');
  s.toString();
  s = null;
  ```

+ 拆箱
  
  + 将引用类型对象转换为对应的值类型对象，它是通过引用类型的valueOf()或者toString()方法来实现的。如果是自定义的对象，你也可以自定义它的valueOf()/tostring()方法，实现对这个对象的拆箱。

#### 内置函数---数据封装类对象（构造函数）

+ Object
+ Array
+ Boolean
+ Number
+ String
+ Function
+ Date
+ RegExp
+ Error

#### 8种数据类型及区别

#### null

+ null不是对象
+ 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

### 判断变量的类型

#### typeof

+ 对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。

  ```
  typeof 1 // 'number'
  typeof '1' // 'string'
  typeof undefined // 'undefined'
  typeof true // 'boolean'
  typeof Symbol() // 'symbol'
  ```

+ 但对于引用数据类型，除了函数之外，都会显示"object"。

  ```
  typeof [] // 'object'
  typeof {} // 'object'
  typeof console.log // 'function'
  ```

+ Object.toString().call()及原理[[class]] 可以输出对象的内部属性[[class]]

+ 举例： typeof null // ’object‘ 、判断数组的方法、判断空对象的方法

#### instanceof及原理

+ **`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链

+ instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true

  ```
  const Person = function() {}
  const p1 = new Person()
  p1 instanceof Person // true
  
  var str1 = 'hello world'
  str1 instanceof String // false
  
  var str2 = new String('hello world')
  str2 instanceof String // true
  
  // 判断基本数据类型
  // 其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。
  class PrimitiveNumber {
    static [Symbol.hasInstance](x) {
      return typeof x === 'number'
    }
  }
  console.log(111 instanceof PrimitiveNumber) // true
  
  ```

#### 手动实现instanceof的功能

+ 核心: 原型链的向上查找。

  ```
  function myInstanceof(left, right) {
      //基本数据类型直接返回false
      if(typeof left !== 'object' || left === null) return false;
      //getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
      let proto = Object.getPrototypeOf(left);
      while(true) {
          //查找到尽头，还没找到
          if(proto == null) return false;
          //找到相同的原型对象
          if(proto == right.prototype) return true;
          proto = Object.getPrototypeOf(proto);
      }
  }
  console.log(myInstanceof("111", String)); //false
  console.log(myInstanceof(new String("111"), String));//true
  ```

####  Object.is和===的区别

+ `**Object.is()**` 方法判断两个值是否是[相同的值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)。
+ 这种相等性判断逻辑和传统的 [`==`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality) 运算不同，[`==`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality) 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 `"" == false` 等于 `true` 的现象），但 `Object.is` 不会做这种类型转换。
+ 这与 [`===`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity) 运算符的判定方式也不一样。[`===`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity) 运算符（和[`==`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality) 运算符）将数字值 `-0` 和 `+0` 视为相等，并认为 [`Number.NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN) 不等于 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)。
+ Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。 

```
function is(x, y) {
  if (x === y) {
    //运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    //NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理
    //两个都是NaN的时候返回true
    return x !== x && y !== y;
  }
```

### 数据类型转换

+ 强制类型和隐式类型转换

#### 类型转换只有三种

- 转换成数字
- 转换成布尔值
- 转换成字符串

#### 数据转换规则

+ 对象 == 字符串，对象toString()变为字符串（对象变为数字=> 先对象.toString(),再Number('字符串'))
+ null == undefined 相等，但是和其他值比较就不在相等了
+  NaN == NaN不相等
+ 剩下的都转换为数字

#### 相等== 和全等 ===

+ ===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如'1'===1的结果是false，因为一边是string，另一边是number。

+ 两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false

+ 判断的是否是null和undefined，是的话就返回true

+ 判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较

+ 判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较

+ 如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较

+ ###  [] == ![]结果是什么

  + == 中，左右两边都需要转换为数字然后进行比较。
  + []转换为数字为0。
  + ![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,
  + 因此![]为false，进而在转换成数字，变为0。
  + 0 == 0 ， 结果为true

#### 对象转原始类型是根据什么流程运行的

+ 对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：
  + 如果Symbol.toPrimitive()方法，优先调用再返回
  + 调用valueOf()，如果转换为原始类型，则返回
  + 调用toString()，如果转换为原始类型，则返回
  + 如果都没有返回原始类型，会报错

#### 如何让if(a == 1 && a == 2)条件成立

```
// 先调用valueOf然后toString
var a = {
	i: 0,
	toString(){
		return ++this.i
	}
}
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
// 用defineProperty,数据劫持
var i = 0 // 不能用a会死循环，栈溢出，
// GETER拦截器中不能再次获取当前属性
Object.defineProperty(window, 'a',{
	get(){
		return ++i
	}
})
// 也是变成字符串重写toSting
var a = [1,2,3]
a.toString = a.shift
console.log(a == 1 && a == 2);//true
```

### 运算符优先级

### 堆栈内存

#### 堆

+ 存储引用类型值的空间

#### 栈

+ 存储基本类型值和指定代码的环境

### JS堆栈内存的运行机制

### 执行上下文和执行栈

#### 执行上下文的类型

+ 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。
+ 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。
+ Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用。

#### 执行栈

+ 执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。
+ 首次运行JS代码时，会创建一个**全局**执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个**新的函数**执行上下文并Push到当前执行栈的栈顶。
+ 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的**函数**执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的**下一个**执行上下文。

#### 执行上下文的创建

##### 创建阶段

- 1、确定 **this** 的值，也被称为 **This Binding**。
- 2、**LexicalEnvironment（词法环境）** 组件被创建。
  - **全局环境**：是一个没有外部环境的词法环境，其外部环境引用为 **null**。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，`this` 的值指向这个全局对象。
  - **函数环境**：用户在函数中定义的变量被存储在**环境记录**中，包含了`arguments` 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。
- 3、**VariableEnvironment（变量环境）** 组件被创建。
  - 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。
  - 在 ES6 中，**词法** 环境和 **变量** 环境的区别在于前者用于存储**函数声明和变量（ `let` 和 `const` ）**绑定，而后者仅用于存储**变量（ `var` ）**绑定。

##### 执行阶段

+ 此阶段，完成对所有变量的分配，最后执行代码。
+ 如果 Javascript 引擎在源代码中声明的实际位置找不到 `let` 变量的值，那么将为其分配 `undefined` 值。

### 函数创建

#### 创建函数

+ 开辟一个堆内存
+ 把函数体中的代码当作字符串存储进去
+ 把堆内存的地址赋值给函数名/变量名
+ **函数在哪里创建，那么它执行时候所需要查找的上级作用域就是谁**

#### 函数执行

+ 形成一个全新的私有作用域、执行上下文、私有栈内存（执行一次形成一个，多个之间也不会产生影响）
+ 形参赋值&变量提升
+ 代码执行（把所属堆内存中的代码字符串拿出来一行行执行）
+ **遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有的就操作自己的变量即可，不是私有的则向上级作用域中查找...一直找到全局作用域为止 => 作用域链查找机制**
+ 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是**闭包的保护机制**

### 变量提升机制

+ **变量提升**的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 `undefined`（在 `var` 的情况下）或保持未初始化（在 `let` 和 `const` 的情况下）。所以这就是为什么可以在声明之前访问 `var` 定义的变量（尽管是 `undefined` ），但如果在声明之前访问 `let` 和 `const` 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。
+ js引擎在代码正式执行之前会做一个预处理的工作：
  + 1、收集变量
  + 2、收集函数
  + 依据：
    +  var 将var后边的变量定义但是不赋值 var a= undefined
    + function(){} 提前定义该函数

+ let/const声明的变量，仍然会提前被收集到变量对象中，但和var不同的是，let/const定义的变量，不会在这个时候给他赋值undefined。
+ 因为完全没有赋值，即使变量提升了，我们也不能在赋值之前调用他。这就是我们常说的**暂时性死区**。

### 作用域AO/VO/GO/EC/ECSTACK

+ 作用域是在代码定义的时候产生的
+ 作用域表示的是一个变量的可用范围、其实它是一个保存变量的对象
+ 活动对象AO（Activation Object）

#### **1、全局作用域**
+ 在JavaScript中的全局作用域其实就是windows
+ 优点：可重复使用，随处可用
+ 缺点：会造成全局污染

#### **2、函数作用域**
+ 临时创建的活动对象AO（Activation Object）、该对象包含了函数的所有局部变量、命名参数、参数集合以及this，**当运行时上下文被销毁、活动也会被销毁（闭包形成的原因其实因为就是因为活动对象被引用着无法被销毁而导致的，详细的请继续往下看）**
+ 优点：不污染全局
+ 缺点：不可重复使用、仅在函数内可以使用

### 变量对象（Variable Object）

+ 变量对象的创建，依次经历了以下几个过程。

+ 1、建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。
+ 2、检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。
+ 3、检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。

### VO与AO的区别

+ 变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。
+ VO 为 Variable Object的缩写，即变量对象，在函数创建阶段。
+ AO为Active Object的缩写，即活动对象，在函数的执行阶段。
+ 1、变量对象（**VO**）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。
+ 2、当进入到一个执行上下文后，这个变量对象才会被**激活**，所以叫活动对象（**AO**），这时候活动对象上的各种属性才能被访问。

### 作用域链

+ 作用域链的概念，在ES5中只存在两种作用域————全局作用域和函数作用域，`当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链`
+ 值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。

### 执行上下文ECSTACK（Execution Context Stack）

+ 理解：代码执行的环境

+ 时机： 代码正式执行之前会进入到执行环境

+ 工作：

  + 1、创建变量对象
    + 变量
    + 函数及函数的参数
    + 全局：winodw
    + 局部：抽象但是确实存在
  + 2、确认this的指向
    + 全局：this	window
    + 局部：this   调用其的对象

  + 3、创建作用域链
  
+ 父级作用域链+ 当前的变量对象
  
+ 4、扩展：
  
    ```
    ECObj={
    	变量对象:{变量，函数，函数的形参}，
    	scopeChain: 父级作用域链 + 当前的变量对象，
    	this: { window || 调用其的对象}
    }
    ```

#### 创建阶段

+ 在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向

+ 作用域链（当前变量对象+所有父级变量对象）
+ 变量对象（参数、变量、函数声明）
+ this

#### 执行阶段

+ 创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。
+ 变量赋值
+ 函数引用
+ 执行其他代码

#### 执行完毕后出栈，等待被回收

### 闭包

#### 什么是闭包

+ 红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，
  + 是一个函数
  + 能访问另外一个函数作用域中的变量
+ MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。 （其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）
+ 密闭的容器，类似于set，map容器，存储数据的
+ 闭包是一个对象，存放数据的格式：key：value

#### 闭包形成的条件

+ 函数嵌套
+ 内部函数引用外部函数的局部变量

#### 闭包产生的原因

+ 闭包产生的本质就是，当前环境中存在指向父级作用域的引用。

#### 闭包的两大作用：

+ 保存
+ 保护

####  闭包及优缺点

+ 闭包的概念和优缺点

+  优点
  + 延长外部函数局部变量的生命周期

+ 缺点：
  + 容易造成内存泄漏

+ 注意点
  + 合理使用闭包
  + 用完闭包要及时清除（销毁）

### JS高阶编程技巧：

#### 惰性函数

#### 柯理化函数

+ **柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。**

#### 高阶函数

+ 高阶函数，就是让当前函数获得额外能力的函数
+ 高阶函数的思路，它其实是一个封装公共逻辑的过程

## 面向对象OOP和this处理

### 单例设计模式

### 类和实例

### 原型和原型链

+ 描述构造函数、实例以及原型之间的关系
+ 构造函数的prototype属性是指向原型的

#### 原型对象

+ 当构造函数被创建出来的时候，会默认关联一个`Ojbect`类型的新对象，这个对象就是当前构造函数的原型对象，构造函数的原型对象默认是一个空对象。
+ 当然，构造函数创建出来的对象可以访问该构造函数原型对象的属性和方法。

##### 访问原型对象

+ 1.构造函数.`prototype`
+ 2.实例对象.`__proto__`
+ 3.`object.getPrototypeOf`(实例对象)

##### prototype

+ `prototype` 函数对象拥有的属性，指向它的原型对象。

##### proto

+ `__proto__` 所有的对象都拥有`__proto__`属性，指向实例的原型。
+ 注：`__proto__`属性并不在`ECMAScript`标准中，只为了开发和调试而生，不具备通用性，不能出现在正式的代码中。

#####  constructor

+ `construtor` 构造器，原型对象可以通过`constructor`来访问其所关联的构造函数。当然，每个实例对象也从原型中继承了该属性。

#### 原型链

```
function Man () {};
function Woman () {};

var m1 = new Man();
var w1 = new Woman();
// 1.让我们看一看食物链(原型链)的顶端 null
console.log(Object.prototype.__proto__);                      //null

// 2.Function.prototype的原型对象为Object.prototype而不是它自己
console.log(Function.prototype.__proto__ == Object.prototype);//true

// 3.Function和Object的构造函数都是Function
console.log(Function.constructor == Function);                //true
console.log(Object.constructor == Function);                  //true

// 4.Function.prototype的构造函数是Function
console.log(Function.prototype.constructor == Function);      //true

// 5.m1的原型对象为Man.prototype
console.log(m1.__proto__ == Man.prototype);  //true

// 6.Man.prototyepe|Woman.prototype的constructor指向Object
// Man.prototyepe|Woman.prototype的原型对象为Object.prototype
// 先删除实例成员，通过原型成员访问
delete  Man.prototype.constructor;
delete  Woman.prototype.constructor;
console.log(Man.prototype.constructor == Object);    //true
console.log(Woman.prototype.constructor == Object);    //true
console.log(Man.prototype.__proto__ == Object.prototype);    //true
console.log(Woman.prototype.__proto__ == Object.prototype);    //true

// 7.Man和Woman的构造函数为Function
// Man和Woman的构造函数的原型对象为空函数
console.log(Man.constructor == Function);                //true
console.log(Woman.constructor == Function);                //true
console.log(Man.__proto__ == Function.prototype);        //true
console.log(Woman.__proto__ == Function.prototype);        //true
```



##### 访问规则

+ **就近原则**

+ 对象在访问属性或方法时，先检查自己的实例，如果存在就直接使用。如果不存在那么就去原型对象上去找，存在就直接使用，如果没有就顺着原型链一直往上查找，找到即使用，找不到就重复该过程直到原型链的顶端，如果还没有找到相应的属性或方法，就返回`undefined`，报错。

  

#### 三种检验方法

+ `Object.getPrototypeOf`方法用于获取指定实例对象的原型对象。
+ `isPrototypeOf`方法用于检查某对象是否在指定对象的原型链中。
+ `instanceof`运算符的作用跟`isPrototypeOf`方法类似，左操作数是待检测的实例对象，右操作数是用于检测的构造函数。如果右操作数指定构造函数的原型对象在左操作数实例对象的原型链上面，则返回结果`true`，否则返回结果`false`。
+ **注意**：不要错误的认为`instanceof`检查的是该实例对象是否从当前构造函数实例化创建的，其实它检查的是实例对象是否从当前指定构造函数的原型对象继承属性。

### new运算符的实现机制（手写实现New）

#### 通过new操作符调用构造函数，会经历以下4个阶段

+ 创建一个新的对象
+ 将构造函数的this指向这个新对象
+ 指向构造函数的代码，为这个对象添加属性，方法等
+ 返回新对象

#### new下构造函数this的指向

+ 当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象

#### 原理

+ 1、创建一个空对象（新对象）
+ 2、让空对象的__proto__（IE没有该属性）成员指向了构造函数的prototype成员对象（新对象会被执行[[prtotype]]链接）
+ 3、使用apply调用构造器函数，属性和方法被添加到 this 引用的对象中（新对象和函数调用的this会绑定起来）
+ 4、执行构造函数代码。如果构造函数中没有返回其它对象，那么返回 this，即创建的这个的新对象，否则，返回构造函数中返回的对象。（如果函数没有返回值，那么就会自动返回这个新对象）

```
function _new(func) {
    // 第一步 创建新对象
    let obj= {};
    // 第二步 空对象的_proto_指向了构造函数的prototype成员对象
    obj.__proto__ = func.prototype;//
    // 一二步合并就相当于 let obj=Object.create(func.prototype)

    // 第三步 使用apply调用构造器函数，属性和方法被添加到 this 引用的对象中
    let result = func.apply(obj);
    if (result && (typeof (result) == "object" || typeof (result) == "function")) {
    // 如果构造函数执行的结果返回的是一个对象，那么返回这个对象
        return result;
    }
    // 如果构造函数返回的不是一个对象，返回创建的新对象
    return obj;
}
/**
 * 模拟实现 new 操作符
 * @param  {Function} ctor [构造函数]
 * @return {Object|Function|Regex|Date|Error}      [返回结果]
 */
function newOperator(ctor){
    if(typeof ctor !== 'function'){
      throw 'newOperator function the first param must be a function';
    }
    // ES6 new.target 是指向构造函数
    newOperator.target = ctor;
    // 1.创建一个全新的对象，
    // 2.并且执行[[Prototype]]链接
    // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。
    var newObj = Object.create(ctor.prototype);
    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);
    // 除去ctor构造函数的其余参数
    var argsArr = [].slice.call(arguments, 1);
    // 3.生成的新对象会绑定到函数调用的`this`。
    // 获取到ctor函数返回结果
    var ctorReturnResult = ctor.apply(newObj, argsArr);
    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null
    var isObject = typeof ctorReturnResult === 'object' && ctorReturnResult !== null;
    var isFunction = typeof ctorReturnResult === 'function';
    if(isObject || isFunction){
        return ctorReturnResult;
    }
    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。
    return newObj;
}

function New(func){
	// 声明一个中间对象，该对象最终返回的实例
	var res = {}
	if(func.prototype !== null){
		// 将实例的原型指向构造函数的原型
		res.__proto__ = func.prototype
	}
	// ret为构造函数执行的结果，这里通过apply
	// 将构造函数内部的this指向修改为指向res，即实例对象
	var ret = func.apply(res, Array.prototype.slice.call(arguments,1))
	// 当在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象
	if((typeof ret === 'object' || typeof ret === 'function') && ret !== null){
		return ret
	}
	// 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象
	return res
}
```

### constructor构造函数模式

### call/apply/bind

#### call

+ `call()` 方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。

+ 当调用一个函数时，可以赋值一个不同的 `this` 对象。`this` 引用当前对象，即 `call` 方法的第一个参数

+ 通过 `call` 方法，你可以在一个对象上借用另一个对象上的方法，比如`Object.prototype.toString.call([])`，就是一个`Array`对象借用了`Object`对象上的方法。

  ```
  语法 fun.call(thisArg[, arg1[, arg2[, ...]]])
  ```

##### thisArg

+ 在fun函数运行时指定的`this`值。需要注意的是下面几种情况

（1）不传，或者传`null`，`undefined`， 函数中的`this`指向window对象
（2）传递另一个函数的函数名，函数中的`this`指向这个函数的引用，并不一定是该函数执行时真正的`this`值  （3）值为原始值(数字，字符串，布尔值)的`this`会指向该原始值的自动包装对象，如 `String`、`Number`、`Boolean`
（4）传递一个对象，函数中的this指向这个对象    

##### arg1, arg2, ...

+ 指定的参数列表。

#### apply

+ 语法与 `call()` 方法的语法几乎完全相同，唯一的区别在于，apply的第二个参数必须是一个包含多个参数的数组（或类数组对象）。`apply`的这个特性很重要，

+ 在调用一个存在的函数时，你可以为其指定一个 `this` 对象。 `this` 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法

  ```
  语法：fun.apply(thisArg[, argsArray])
  ```

+ **注意:** 需要注意：`Chrome 14` 以及 `Internet Explorer 9` 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。

#### bind

+ bind() 函数会创建一个新函数（称为绑定函数）
  - bind是ES5新增的一个方法
  - 传参和call或apply类似
  - 不会执行对应的函数，call或apply会自动执行对应的函数
  - 返回对函数的引用

```
语法 fun.bind(thisArg[, arg1[, arg2[, ...]]])
```



### this指向

+ 作用域
+ 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。**如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined**。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。

### this五种情况的综合梳理

#### 纯粹的函数调用

+  函数最普通用法，此时属于全局调用，函数内this指向全局对象window。

#### **作为对象的方法使用**

+  函数作为某个对象的方法，此事this指向该对象。

#### **构造函数生成实例对象**

+ 作为构造函数使用时，this指向该对象新创建的实例。

#### **使用apply**

+ apply()方法是改变函数内部this的值，若为空默认是指向全局对象window。

#### **事件处理程序中的this**

+  在DOM级事件处理程序中this指向触发事件的元素，而对于IE事件来说，this指向全局对象window。

### 深拷贝/浅拷贝

#### 浅拷贝

+ 浅拷贝的意思就是只复制引用，而未复制真正的值。

#### 深拷贝

+ 深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。

##### 利用 `JSON` 对象中的 `parse` 和 `stringify`

+ `JSON.stringify` 是将一个 `JavaScript` 值转成一个 `JSON` 字符串。

+ `JSON.parse` 是将一个 `JSON` 字符串转成一个 `JavaScript` 值或对象。

  ```
  const originArray = [1,2,3,4,5];
  const cloneArray = JSON.parse(JSON.stringify(originArray));
  console.log(cloneArray === originArray); // false
  
  const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
  const cloneObj = JSON.parse(JSON.stringify(originObj));
  console.log(cloneObj === originObj); // false
  
  cloneObj.a = 'aa';
  cloneObj.c = [1,1,1];
  cloneObj.d.dd = 'doubled';
  
  console.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};
  console.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
  ```

+ 注意：`undefined`、`function`、`symbol` 、正则会在转换过程中被忽略。

##### 递归的方法

```
function deepClone(source){
  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象
  for(let keys in source){ // 遍历目标
    if(source.hasOwnProperty(keys)){
      if(source[keys] && typeof source[keys] === 'object'){ // 如果值是对象，就递归一下
        targetObj[keys] = source[keys].constructor === Array ? [] : {};
        targetObj[keys] = deepClone(source[keys]);
      }else{ // 如果不是，就直接赋值
        targetObj[keys] = source[keys];
      }
    } 
  }
  return targetObj;
}
 function deepClone(obj){
 		// 过滤特殊情况
 		if(obj === null) return null;
 		if(typeof obj !== 'object') return obj;
 		if(obj instanceof RegExp){
 			return new RegExp(obj)
 		}
 		if(obj instanceof Date){
 			return new Date(obj)
 		}
 		// 不直接创建空对象目的：克隆的结果和之前保持相同的所属类
 		let newObj = new obj.constructor;
 		for(let key in obj){
 			if(obj.hasOwnProperty(key)){
 				newObj[key] = deepClone(obj[key])
 			}
 		}
 		return newObj
}

// 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型
function cloneDeep(target,map = new WeakMap()) {
  if(typeOf taret ==='object'){
     let cloneTarget = Array.isArray(target) ? [] : {};
      
     if(map.get(target)) {
        return target;
    }
     map.set(target, cloneTarget);
     for(const key in target){
        cloneTarget[key] = cloneDeep(target[key], map);
     }
     return cloneTarget
  }else{
       return target
  }
}
```

#### JavaScript中的拷贝方法

##### concat

+ 该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。
+ **结论：`concat` 只是对数组的第一层进行深拷贝。**

##### slice

+ slice() 方法可从已有的数组中返回选定的元素。
+ **结论：`slice` 只是对数组的第一层进行深拷贝。**

##### Object.assign()

+ **结论：`Object.assign()` 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。**

##### ... 展开运算符

+ **结论：`...` 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。**

### 四大数据类型检测方法

### 四大继承方案

### 实现继承的几种方式

+ 红宝书162页

#### 最佳的组合继承方案

+ 1.使用原型链实现对原型属性和方法的继承
+ 2.通过伪造(冒充)构造函数来实现对实例成员的继承，并且解决了父构造函数传参问题

```
// 1 提供超类型|父类型
function SuperClass(name) {
    this.name = name;
    this.showName = function () {
        console.log(this.name);
    }
}

// 2 设置父类型的原型属性和原型方法
SuperClass.prototype.info = 'SuperClass的信息';
SuperClass.prototype.showInfo = function () {
    console.log(this.info);
};

// 3 提供子类型
function SubClass(name) {
    SuperClass.call(this,name);
}

// 获取父构造函数的实例成员  Person.call(this,name);
// 获取父构造函数的原型成员  SubClass.prototype = SuperClass.prototype;
SubClass.prototype = SuperClass.prototype;
SubClass.prototype.constructor = SubClass;

var sub_one = new SubClass("zhangsan");
var sub_two = new SubClass("lisi");
console.log(sub_one);
console.log(sub_two);

```

## DOM/BOM及事件处理机制

### DOM/BOM核心的操作

### DOM事件流和事件委托

+ 捕获、冒泡
+ 事件委托及好处

+ DOM事件流红宝书374页，事件委托在402页

### 发布订阅的设计模式

### 事件传播机制和事件代理

### DOM2级事件的核心运行机制

### 移动端Touch/Gesture事件及封装处理

### 浏览器底层渲染机制和DOM的回流重绘

### DIALOG模态框组件的封装

### Cookie/storage

+ cookie的构成
+ localStorage和sessionStorage
+ 他们的区别
+ storge的最大存储空间
+ cookie的HTTPOnly字段加上后就无法通过js获取cookie，从而防止xss攻击

### Cookie,LocalStorage,SessionStorage

| 特性           | Cookie                                                       | LocalStorage                                                | SessionStorage                               |
| -------------- | ------------------------------------------------------------ | ----------------------------------------------------------- | -------------------------------------------- |
| 数据的生命期   | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存                                    | 仅在当前会话下有效，关闭页面或浏览器后被清除 |
| 存放数据大小   | 4K左右                                                       | 一般为5MB                                                   |                                              |
| 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信          |                                              |
| 易用性         | 需要程序员自己封装，源生的Cookie接口不友好                   | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |                                              |

### 

### 数组和对象的常见方法

+ Array：slice/splice/concat/filter/map/reduce
+ Object：keys/assign用于浅拷贝
+ 改变原数组的方法

### 防抖/节流

+ **函数防抖** 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。
+ **函数节流** 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。

```

// 函数防抖的实现
function debounce(fn, wait) {
  var timer = null;

  return function() {
    var context = this,
      args = arguments;

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}

// 函数节流的实现;
function throttle(fn, delay) {
  var preTime = Date.now();

  return function() {
    var context = this,
      args = arguments,
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}

```



##  ES6/ES7的核心知识

### requestAnimationFrame

+ 动画，相比于setInterval实现动画效果requestAnimationFrame的优势是什么

+ 

### let/const/var的区别

### 箭头函数ArrowFunction

### 解构赋值和拓展运算符

### Set/Map数据结构

+ Set/Map，数据结构

####  Set

+ 它类似于数组，但是其成员的值都是唯一的，没有重复的值（甚至在Set内部，NaN和NaN是相等的）

+ `Set`本身是一个构造函数，用来生成 Set 数据结构。

  ```
  const s = new Set();
  
  [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
  
  for (let i of s) {
    console.log(i);
  }
  // 2 3 5 4
  ```

+ **set同样也有属性用于获取它里面数据的长度**size
+ 然后set结构也是可以遍历的，但是不能再简单的用for循环去进行遍历，而是要用forEach方法。
+ **add(value)：**
  + 用于往set里面添加新的值，返回值是set结构本身。
  + add方法是用来往set结构里面添加值的，其返回值就是set结构本身，并且一次只能添加一个值。
  + 如果用add方法去添加一个set结构里面已经存在的值的话是没有作用的。

+ **delete(value)：**
  
+ 用于删除某个值，返回一个布尔值，表示删除是否成功。
  
+ **has(value)：**
  
+ 返回一个布尔值，用于判断该值是否是set的成员。
  
+ **clear()：**
  
  + 用于清除所有成员，没有返回值。

#### weakSet

+ **weakset和set很相似，也是不重复的值的集合。**

+ **区别在于：**
+ WeakSet的成员只能是对象，而不能是其他类型的值。
+ WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用；
+ 也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。
+ 这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。

#### Map

+ Map结构提供了“值 —— 值”的对应，是一种更完善的结构实。
+ Map和Object类似，也是键值对的集合。
+ 但是Map的键不再仅限于字符串，任何数据类型都可以作为Map结构的键名；
+ 甚至Object都可以做为键名。
+ Map在初始化的时候，接收一个二维数组作为参数，二维数组里面的第一项和第二项将被作为一个键值对存入Map结构中。

+ set('key','content')：
  + 用于往Map里面添加新的值，返回值是Map结构本身。
+ get('key')：
  + 用于获取key对应的值，返回获取到的值
+ has('key')：
  + 返回一个布尔值，用于判断该值是否是Map的成员。
+ delete('key')：
  + 用于删除指定的键值，返回一个布尔值，用于表示删除是否成功
+ clear()：
  + 用于清除Map结构里的所有数据，没有返回值

+ 注意： **我们在用对象多为键名存数据的时候，一定要用变量名指向这个对象；**

### 实现一个Symbol

### 异步编程：Promise和async await

+ 内部状态
+ Promise.race和Promise.all

### Promise设计模式

### async/await及实现原理

#### async/await 基础语法

```
// 定义一个异步函数（假设他是一个异步函数）
getJSON(){
    return 'JSON'
}

// 在需要使用上面异步函数的函数前面，加上async声明，声明这是一个异步函数
async testAsync() {
  // 在异步函数前面加上await，函数执行就会等待用await声明的异步函数执行完毕之后，在往下执行
  await getJSON()
  
  ...剩下的代码
}
async testAsync() {
  try {
     await getJSON()
  } catch(err) {
     console.log(err)
  }
  ...剩下的代码
}
```

+ 还需要注意的一点就是使用async/await的时候，是无法捕获错误的，这个时候就要用到我们es5里面一个被大家遗忘了的try/catch，来进行错误的捕获：
+ 1.async函数在声明形式上和普通函数没有区别，函数声明式，函数表达式，对象方法，class方法和箭头函数等都可以声明async函数。
+ 2.任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。
+ 3.**async函数返回的 Promise 对象**，**必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误**。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。
+ async函数，返回的是一个Promise对象
+ await是英文单词‘等待’的意思，代表的意思也是等待，那他等的到底是个什么东西呢？还是一个Promise。

#### async/await和Promise直接的转化

+ async/await其实是基于Promise的。async函数其实是把Promise包装了一下。
+ 因为await本身返回的也是一个Promise,它只是把await后面的代码放到了await返回的Promise的.then后面，以此来实现的。

### Generator生成函数

### Interator迭代器和for of循环

### Promise A+规范（手写Promise源码）

+ https://www.bilibili.com/video/BV1yJ411771n

### JS底层运行机制：单线程和同步异步编程

### JS底层运行机制：微任务宏任务和事件循环机制

+ evetLoop
+ 单线程、解释性语言
+ 事件循环
+ 宏任务/微任务

# 正则

## 零宽断言



# 网络通信层

## AJAX/Fetch/axios

### AJAX核心四步骤

+ 原理

### axios库和源剖析

### fetch基础和实战应用

###  Web Worker



## HTTP

### Http1.0/2.0

### TCP

#### TCP三次握手和四次挥手

### GET/POST核心机制与区别

### HTTP网络状态码和实战中的处理方案



## 跨域处理方案

### 性能优化



# 浏览器

## 内存回收

+ JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。

#### 局部变量和全局变量的销毁

+ 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。
+ 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。

#### 以Google的V8引擎为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的

+ 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
+ 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。

#### V8引擎对堆内存中的JS对象进行分代管理

+ 新生代：存活周期较短的JS对象，如临时变量、字符串等。
+ 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

## 垃圾回收

+ 红宝书78页
+ 垃圾回收GC的全拼是 Garbage Collection 其在维基百科的定义是： 在计算机科学中，**垃圾回收**（英语：Garbage Collection，缩写为GC）是一种自动的[内存管理](https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/記憶體管理)机制。当一个电脑上的动态内存不再需要时，就应该予以释放，以让出内存，这种内存资源管理，称为垃圾回收（garbage collection）

#### 可达性

+ 简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。
+ **1. 有一组基本的固有可达值，由于显而易见的原因无法删除。这些值称为根，例如:**
  - 本地函数的局部变量和参数
  - 当前嵌套调用链上的其他函数的变量和参数
  - 全局变量
  - 还有一些其他的，内部的

+ **2. 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。**

#### 垃圾回收算法

##### 一、 标记-清除算法 Mark-Sweep GC

+ 标记清除算法将“不再使用的对象”定义为“**无法到达的对象**”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，**保留**。那些从根部出发无法触及到的对象被标记为**不再使用**，稍后进行回收。

+ 如字面意思 mark-sweep 分为两个阶段：
  1. 标记阶段：从根集合出发，将所有活动对象及其子对象打上标记
  2. 清除阶段：遍历堆，将非活动对象（未打上标记）的连接到空闲链表上

+ 垃圾回收步骤

  + 垃圾回收器获取根并“标记”(记住)它们。
  + 然后它访问并“标记”所有来自它们的引用。
  + 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
  + 以此类推，直到有未访问的引用(可以从根访问)为止。除标记的对象外，所有对象都被删除。
  + 除标记的对象外，所有对象都被删除。

+ #### 优点

  + 实现简单， 容易和其他算法组合

+ 缺点
  + 碎片化， 会导致无数小分块散落在堆的各处
  - 分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块
  - 与写时复制技术不兼容，因为每次都会在活动对象上打上标记

##### 二、标记-压缩 Mark-Compact

+ 和“标记－清除”相似，不过在标记阶段后它将所有活动对象紧密的排在堆的一侧（压缩），消除了内存碎片， 不过压缩是需要花费计算成本的。如下图过程，标记后需要定位各个活动对象的新内存地址，然后再移动对象，总共搜索了3次堆。

+ #### 优点

  + 有效利用了堆，不会出现内存碎片 也不会像复制算法那样只能利用堆的一部分

+ 缺点

  + 压缩过程的开销，需要多次搜索堆

##### 三、引用计数 Reference Counting

+ 引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为0则直接回收内存。 很明显，引用计数最大的优势是暂停时间短
+ 优点
  + 可即刻回收垃圾
  + 最大暂停时间短
  + 没有必要沿指针查找， 不要和标记-清除算法一样沿着根集合开始查找
+ 缺点---致命的问题，那就是**循环引用**
  + 计数器的增减处理繁重
  + 计数器需要占用很多位
  + 实现繁琐复杂， 每个赋值操作都得替换成引用更新操作
  + 循环引用无法回收
  + 如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。

##### 四、 GC 复制算法

+ 堆分为两个大小相同的空间 From 和 To， 利用 From 空间进行分配，当 From 空间满的时候，GC将其中的活动对象复制到 To 空间，之后将两个空间互换即完成GC。
+ 优点
  + 优秀的吞吐量， 只需要关心活动对象
  + 可实现高速分配； 因为分块是连续的，不需要使用空闲链表
  + 不会发生碎片化
  + 与缓存兼容
+ 缺点
  + 堆使用率低
  + 与保守式GC不兼容
  + 递归调用函数， 复制子对象需要递归调用复制函数 消耗栈

##### 五、 保守式GC

+ 根空间有以下几种：

  + 寄存器
  + 调用栈
  + 全局变量空间
+ 但这些都是不明确的根， 因为调用栈里边的调用帧(call frame) 既有指针也有非指针（值类型）
+ 保守式GC检查不明确根的基本项目：
  + 是不是被正确对齐的值？（在32位cpu的情况下，为4的倍数）
  + 是不是指针堆内？
  + 是不是指着对象的开头？
+ 有种情况是，非指正和堆里的对象地址一样；这时保守式GC “把可以的东西看做指针，稳妥处理”
+ 优点
  + GC不依赖于语言处理程序
+ 缺点
  + 识别指针和非指针需要成本
  + 错误识别指针会压迫堆； 可能错将非指针当做指针,然后将其作为内存地址使得对应堆中的死对象当做活对象
  + 能够使用的gc算法有限； 不能使用复制算法这类移动对象的gc算法

+ 准确式GC
  + 需要依赖 “语言处理程序的支援”，能基于能精确识别指针和非指针的“正确根”来执行gc

##### 六、分代回收

+ 出发点：大部分对象生成后马上就变成垃圾，很少有对象能活的很久
+ 新生代 = 生成空间 + 2 * 幸存区 复制算法
+ 老年代 标记-清除算法
+ 对象在生成空间创建，当生成空间满之后进行 minor gc，将活动对象复制到第一个幸存区，并增加其“年龄” age，当这个幸存区满之后再将此次生成空间和这个幸存区的活动对象复制到另一个幸存区，如此反复，当活动对象的 age 达到一定次数后将其移动到老年代； 当老年代满的时候就用标记-清除或标记-压缩算法进行major gc
+ 吞吐量得到改善， 分代垃圾回收花费的时间是GC复制算法的四分之一；但是如果部分程序新生成对象存活很久的话分代回收会适得其反

##### 七、增量式GC

+ 本来gc只是默默的在幕后回收资源的，但是如果gc任务繁重则会长时间暂停应用程序的执行， 增量式gc就是一种逐渐推进垃圾回收来控制mutator最大暂停时间的方法

+ #### 三色标记算法

  - 白色： 还未搜索过的对象
  - 灰色： 正在搜索的对象
  - 黑色： 搜索完成的对象

+ **根查找阶段**： 对能直接从根引用的对象打上标记，堆放到标记栈里（白色 涂成 灰色）
+ **标记阶段**： 从标记栈中取出对象，将其子对象涂成灰色；这个阶段不是一下子处理所有的灰色对象，而只是处理一定个数，然后暂停gc
+ **清除阶段**： 将没被标记的白色对象连接到空闲链表，并重置已标记的对象标记位

#### 一些优化

- **分代回收**——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。
- **增量回收**——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。
- **空闲时间收集**——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。

## 内存泄漏

+ 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）

### 内存泄漏识别方法

#### 浏览器方法

+ 打开开发者工具，选择 Memory
+ 在右侧的Select profiling type字段里面勾选 timeline
+ 点击左上角的录制按钮。
+ 在页面上进行各种操作，模拟用户的使用情况。
+ 一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。

#### 命令行方法

+ 使用 `Node` 提供的 `process.memoryUsage` 方法。

  

### 设计模式

### 浏览器渲染原理

## Event Loop

### 进程和线程

#### 进程

+ 应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据和其他系统资源所组成。
+ 进程：资源分配的最小单位

#### 线程

+ 线程是进程内的一个独立执行单元，在不同的线程之间是可以共享进程资源的。
+ 线程：程序执行的最小单位

#### event Loop

+ 栈中的代码会调用各种外部API，它们在任务队列中加入各种事件(onClick,onLoad,onDone)，只要栈中的代码执行完毕(js引擎存在`monitoring process`进程，会持续不断的检查主线程执行栈是否为空)，主线程就回去读取任务队列，在按顺序执行这些事件对应的回调函数。也就是说主线程从任务队列中读取事件，这个过程是循环不断的，所以这种运行机制又成为`Event Loop`(事件循环)。

### 宏任务和微任务

#### 宏任务

+ 同步任务和异步任务的划分其实并不准确，准确的分类方式是宏任务(Macrotask)和微任务(Microtask)。
+ 宏任务包括：`script(整体代码)`, `setTimeout`, `setInterval`, `requestAnimationFrame`, `I/O`,`setImmediate`。Ajax
+ 其中`setImmediate`只存在于Node中，`requestAnimationFrame`只存在于浏览器中。

#### 微任务

+ 微任务包括： `Promise`, `Object.observe`(已废弃), `MutationObserver`(html5新特性)，`process.nextTick`。
+ 其中`process.nextTick`只存在于Node中，`MutationObserver`只存在于浏览器中。

#### **注意：**

+ ` UI Rendering`不属于宏任务，也不属于微任务，它是一个与微任务平行的一个操作步骤。

### 执行方法

+ 这种分类的执行方式就是，执行一个宏任务，过程中遇到微任务时，将其放到微任务的事件队列里，当前宏任务执行完成后，会查看微任务的事件队列，依次执行里面的微任务。如果还有宏任务的话，再重新开启宏任务……

### Node下的Event Loop



## Web Worker

+ HTML5的新特性`Web Worker`
+ 为了解决不可避免的耗时操作(多重循环、复杂的运算)，HTML5提出了`Web Worker`，它会在当前的js执行主线程中开辟出一个额外的线程来运行js文件，这个新的线程和js主线程之间不会互相影响，同时提供了数据交换的接口：`postMessage`和`onMessage`
+ 但是因为它创建的子线程完全受控于主线程，且位于外部文件中，无法访问DOM。所以它并没有改变js单线程的本质。





# Hybird或者APP再或者小程序

### Hybrid

 ### uni-app

### RN

### Flutter

### 小程序MPVUE

### Weex

### PWA

# 工程化方面

### webpack

### git

### linux/nginx

# 全栈方面

### node

### express

### koa2

### mongodb

### nuxt.js/next.js

# 框架

## Vue

### 基础知识

### 核心原理

### MVVM的理解

+ Model-View-ViewModel的缩写，Model代表数据模型，View代表UI组件,ViewModel将Model和View关联起来
+ 数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知**viewModel**层更新数据

### **Vue2.x响应式数据/双向绑定原理**

+ Vue 数据双向绑定主要是指：**数据变化更新视图，视图变化更新数据**。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何**根据Data变化更新View**。

#### 简述

+ 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。
+ 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。
+ 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

#### 深入理解

+ **监听器 Observer**：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。
+ **解析器 Compile**：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。
+ **订阅者 Watcher**：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式
+ **订阅器 Dep**：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。

### **Vue3.x响应式数据原理**

#### **Vue3.x改用Proxy替代Object.defineProperty**

- 因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。

- Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？

- - 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。(Reflect.get`方法查找并返回`target`对象的`name`属性，如果没有该属性，则返回`undefined)
  - 监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。

#### **Proxy 与 Object.defineProperty 优劣对比**

- Proxy 的优势如下:

- - Proxy 可以直接监听对象而非属性；

- Proxy 可以直接监听数组的变化；

- - Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
  - Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
  - Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

- Object.defineProperty 的优势如下:

- - 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。

### **vue2.x中如何监测数组变化**

+ 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。
+ 如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

- vm.`$set` 的实现原理是：

- - 如果目标是数组，直接使用数组的 splice 方法触发相应式；
  - 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）

### vue中的diff算法

#### 原理： （patchVnode是diff发生的地方，整体策略：深度优先，同层比较）

- 1.先同级比较，在比较子节点
- 2.先判断一方有儿子一方没儿子的情况 
- 3.比较都有儿子的情况 
- 4.递归比较子节点

#### 总结：

- 1.diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM作对比（即diff），将变化的地方更新在真实DOM上；另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)。

- 2.vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方。

- 3.vue中diff执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。

- 4.diff过程整体遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效

### **虚拟Dom以及key属性的作用**



### 更新DOM

+ template->render函数 ->AST->patch -> vnode ->dom ->dom api update

### nextTick实现原理是什么

- 在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。
- nextTick主要使用了**宏任务**和**微任务**。
- 根据执行环境分别尝试采用
  - Promise、
  - MutationObserver、
  - setImmediate，
  - 如果以上都不行则采用setTimeout

+ 定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

### **Vue事件绑定原理是什么**

+ 原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的`$on`实现的。

### Vue 的父组件和子组件生命周期钩子函数执行顺序

+ 加载渲染过程： 父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted
+ 子组件更新过程： 父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
+ 父组件更新过程： 父 beforeUpdate -> 父 updated
+ 销毁过程： 父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

#### 如何子代修改父代

+ ##### 子代修改父代

  - 订阅自定义事件：调用组件的时候基于属性传递一个方法 （父）

    ```
    <my-component @func='xxx'></my-component>
    
    new Vue({
      methods:{
        xxx(value){
          //=>value是this.$emit时候传递的第二个参数值
        }
      }
    });
    
    ```

  - 通知自定义事件执行 （子）

    ```
    {
      methods:{
        xxx(){
          this.$emit('func',10);
        }
      }
    }
    ```

  - 也可以基于此方法实现兄弟组件（父子组件、隔代组件）之间的信息通信EventBus($on/$emit)

    ```
    let eventBus=new Vue; //=>创建事件总线
    
    //A组件
    eventBus.$on('xxxA',this.func);
    
    //B组件
    eventBus.$emit('xxxA');
    ```

+ 基于ref实现父子组件信息通信

  - ref 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，基于此可以快速获取和操作子组件中的数据
  - $parent和$children是获取组件和子组件的实例，只不过$children是一个数组集合，需要我们记住组件顺序才可以

+ 基于provide和inject实现祖先与后代的通信

  - 祖先组件基于provide注册需要供后代组件使用的数据

    ```\
    {
      provide:{ //=>对象或者返回对象的函数都可以（属性值如果是data中的数据，则必须使用函数的方法进行处理）
        name:'eggs',
        year:10
      },
      ...
    }
    ```

  - 后代组件基于inject声明需要使用的数据并调取使用

    ```
    {
      inject:['name'],
      methods:{
        func(){
          let name=this.name;
        }
      }
    }
    ```

    

### 什么是MVC，MVP，MVVM

#### MVC

+ Model 代表数据模型，主要任务就是操作数据
  + 将新的数据发送到View，用户得到反馈
+ View 代表UI视图，主要任务将数据模型转换成UI视图展现出来
  + 传送指令到Contrller
+ Controller 控制器，主要任务负责处理业务逻辑
  + 完成业务逻辑后，要求Model改变状态

#### MVP

+ 各部分之间的通信，都是双向的
+ View与Model不发生联系，都通过Presenter传递
+ View非常薄，不部署任何业务逻辑，成为“被动试图”（Passive View），即没有任何主动性，而Presenter非常厚，所有逻辑都部署在哪里

#### MVVM

+ Model 代表数据模型，主要任务就是操作数据

+ View 代表UI视图，主要任务将数据模型转换成UI视图展现出来

+ ViewModel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View和Model的对象，链接Model和View

+ 在MVVM架构下，View和Model之间并没有直接的联系，而是通过ViewModel进行交互，Model和ViewModel之间的交互式双向的，因此View数据的变化会同步到Model中，而Model数据的变化也会立即反应到View上

+ ViewModel通过双向的数据绑定吧View层和Model层链接了起来，而View和Model之间的同步工作完全是自动的，无需人为干涉，因此开发者只需要关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM来统一管理

  

### Vue组件化

+ 任何一个页面我们都可以抽象成由一堆组件构成的一个大的组件树，大到一个页面，小到一个按钮都可以是一个组件，一个页面就是有由很多的组件嵌套拼接组成，这就是组件化

+ 组件化的好处：复用性强，分工开发，代码好管理，耦合度低

+ Vue如何创建组件：

  + 全局组件

    ```
    Vue.component('组件的名称'，组件详情的对象)
    ```

  + 局部组件

    ```
    new Vue({
    	components:{
    		组件名称：组件详情的对象
    	}
    })
    ```

  + 单文件组件

    ```
    // .vue文件
    <template>
    <style>
    <script>
    ```

### v-if和v-for哪个优先级更高？如果两个同时出现，应该怎么优化得到更好的性能？

- 源码中找答案compiler/codegen/index.js
- 显然v-for优先于v-if被解析（把你是怎么知道的告诉面试官）
- 如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能
- 要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环
- 如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项

### Vue组件data为什么必须是个函数而Vue的根实例则没有此限制？

- 源码中找答案：src\core\instance\state.js - initData()
- Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。
- 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。
- 如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。
- 组件复用时所有组件实例都会共享data，如果data是对象的话，就会造成一个组件修改data以后会影响到其他所有组件，所以需要将data写成函数，每次用到就调用一次函数获得新的数据
- 当我们使用new Vue()的方式的时候，无论我们将data设置为对象还是函数都是可以的，因为new Vue()的方式是生成一个根组件，该组件不会复用，也就不存在共享data的情况了。

### v-show 和 v-if区别

+ 实现本质：
  + v-show：通过display：none和display：block之间切换
  + v-if：通过DOM节点的插入，删除来实现切换

+ 性能对比：

  + v-if：
    + 切换时需要删除、插入节点开销大
    + 但是在初始化的时候，如果条件是false是不会插入节点渲染的会节约性能
    + 总结：如果不是频繁切换只需要，渲染时条件渲染用v-if

  + v-show：
    + 有更高的初始渲染开销。就算是false也会渲染
    + 但是在切换的时候只是改变样式，消耗少。
    + 总结：在频繁切换的时候用v-show

- 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。
- v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；
- v-show 则适用于需要非常频繁切换条件的场景。

### 方法调用、computed、watch的区别

#### 方法

+ 页面数据每次重新渲染都会重新执行。性能消耗大。除非不希望有缓存的时候用。

#### computed

+ 是计算属性，依赖其他属性计算值，并且coputed的值有缓存，只有当计算值变化才会返回内容。
+ 是计算属性，依赖其它属性值，并且 computed 的值有**缓存**，只有它**依赖的属性值**发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；

#### watch

+ 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。
+ 没有缓存性，更多的是「**观察**」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听

#### 总结

+ 除非不希望缓存，一般都不会用方法。
+ 一般来说需要依赖别的属性来动态获得值的时候可以使用computed
+ 对于监听到值的变化需要做异步操作或开销较大的操作时用watch

- **运用场景**：

- - 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
  - 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用watch选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

### 生命周期

#### 什么是生命周期

+ 生命周期就是物体从诞生到死亡的过程，vue的生命周期就是vue从初始化到销毁的过程

#### 什么是钩子函数

+ 在生命周期的过程中我们有很多特殊的时间段，我希望在这些特殊的时间段对vue做一些事情，所以出现了钩子函数。
+ 钩子函数就是作者在设计vue的时候，在vue从初始化到销毁这段时间内到特出时段给我们一些定义函数的权利
+ 如果咱们定义了，就会执行，不定义就不会执行

#### vue都有哪些生命周期

+ beforeCreate 创建前
  + 刚执行new的操作，其他什么都没做
+ created 创建后
  + 属性和方法挂载到实例上面
+ beforeMout 挂载前
  + 找到了el或者mout对应的节点范围，但是数据还没替换
+ mouted 挂载后
  + vue范围内的变量会被替换成data里对应的数据值
+ beforeUpdate 数据更新前
+ updated 数据更新后
+ beforeDestroy 销毁前
+ destroyed 销毁后

#### 我们在项目中都什么时候用到

+ 我们在页面初始化时候需要获取数据，这个时候就可以在生命周期里调用

  

### keep-alive组件有什么作用

+ 动态组件如果不加keep-alive相当于每次都会销毁，诞生
+ 如果你需要在切换的时候，保存一些组件的状态防止多次渲染，就可以使用keep-alive组件包裹需要保存的组件
+ keep-alive单独的两个生命周期
  + activated
  + deactivated

+ 用keep-alive包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行deactivated钩子函数

+ Props：

  + include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
  + exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
  + max - 数字。最多可以缓存多少组件实例。



### 父子组件通信

#### **prop 和 events**

+ 通过 `prop` 向下传递，通过事件向上传递是一个 vue 项目最理想的通信状态。

+ 两点需要注意

  + 第一，不应该在一个子组件内部改变 `prop`，这样会破坏单向的数据绑定，导致数据流难以理解。如果有这样的需要，可以通过 `data` 属性接收或使用 `computed` 属性进行转换。
  + 第二，如果 `props` 传递的是引用类型(对象或者数组)，在子组件中改变这个对象或数组，父组件的状态会也会做相应的更新，利用这一点就能够实现父子组件数据的“双向绑定”，虽然这样实现能够节省代码，但会牺牲数据流向的简洁性，令人难以理解，最好不要这样去做。想要实现父子组件的数据“双向绑定”，可以使用 `v-model` 或 `.sync`。

+ ##### props 是如何拿到父组件的变量

  + 父组件的模板会被解析成一个 模板渲染函数，这时候渲染函数会用with绑定作用域，模板函数会被执行，执行时会绑定父组件为作用域，所以渲染函数内部所有的变量，都会从父组件对象 上去获取

  + 每一个 实例都会有 一个 _props 的同时，也会把属性直接放在 实例上。

+ 组件怎么读取props

  + prop 的数据会被 逐一复制到 vm对象上（子组件的实例 this） 上，但是复制的时候，会对每个属性，同时设置 get 和 set 函数，进行 访问转接 和 赋值转接。

    + ##### 访问转接:你访问 props 其中一个值 vm.childName，其实访问的是 vm._props.childName

    + ##### 赋值转接:你赋值 vm.childName= 5 ，其实是赋值 vm._props.childName= 5。但是你直接在这里给 props 赋值，你是不会影响到 父组件的data 的好吧，两个东西完全没有关系

    ```
    Object.defineProperty(vm, key, {    
    
        get() {        
    
            return this._props[key]
    
        },    
    
        set(val) {        
    
            this._props[key] = val
    
        }
    });
    ```

+ 父组件数据变化，子组件props如何更新

  + 每一个实例都会存在 一个 专属watcher

  + 这个watcher 的作用

    + 1、用于实例自己更新视图
    + 2、用于给 依赖的属性保存，然后属性变化的时候，通知实例更新

  + ##### 以 parentName 为例，讲解更新，parentName 是 父组件的 data，然后传给子组件的props，parentName 会收集 父组件的 watcher，

  + 在 父组件渲染函数中，因为 Vue 会对组件的渲染函数进行缓存，所以更新的时候，不需要重新解析，直接读取缓存，会加快渲染速度

  + 然后渲染函数执行，开启新一轮的 props 赋值操作。

#### 总结

+ 1、父组件 data 的值 和 子组件的 props 一般是没有任何联系的，更改 props 不影响父组件 data，但是如果传入的是 对象，那么修改对象，是会影响父组件的，因为数据是原样传入的，所以修改对象，两个地方都会影响
+ 2、props 也是响应式的，跟 data 本质 差不多
+ 3、props 会访问转接，赋值转接 ，其实操作的是 vm._props 的属性

#### **v-model 指令**

+ `v-model` 是用来在表单控件或者组件上创建双向绑定的，他的本质是 `v-bind` 和 `v-on` 的语法糖，在一个组件上使用 `v-model`，默认会为组件绑定名为 `value` 的 `prop` 和名为 `input` 的事件。

+ 当我们组件中的某一个 `prop` 需要实现上面所说的”双向绑定“时，`v-model` 就能大显身手了。有了它，就不需要自己手动在组件上绑定监听当前实例上的自定义事件，会使代码更简洁。

  ```
  <!--父组件-->
  <template>
      <base-input v-model="input"></base-input>
  </template>
  <script>
      export default {
          data() {
              return {
                  input: ''
              }
          },
      }
  </script>
  
  <!--子组件-->
  <template>
      <input type="text" :value="currentValue"  @input="handleInput">
  </template>
  <script>
      export default {
          data() {
              return {
                  currentValue: this.value === undefined || this.value === null ? ''
              }
          },
          props: {
              value: [String, Number],
          },
          methods: {
              handleInput(event) {
                  const value = event.target.value;
                  this.$emit('input', value);
              },
          },
  }
  </script>
  ```

+ 有时，在某些特定的控件中名为 `value` 的属性会有特殊的含义，这时可以通过 `model` 选项来回避这种冲突。

#### **.sync 修饰符**

+ `.sync` 修饰符在 vue 1.x 的版本中就已经提供，1.x 版本中，当子组件改变了一个带有 `.sync` 的 `prop` 的值时，会将这个值同步到父组件中的值。这样使用起来十分方便，但问题也十分明显，这样破坏了单向数据流，当应用复杂时，debug 的成本会非常高。
+ **于是乎**，在vue 2.0中移除了 `.sync`。但是在实际的应用中，`.sync` 是有它的应用场景的，所以在 vue 2.3 版本中，又迎来了全新的 `.sync`。
+ 新的 `.sync` 修饰符所实现的已经不再是真正的双向绑定，它的本质和 `v-model` 类似，只是一种缩写。

```
<text-document
  v-bind:title="doc.title"
  v-on:update:title="doc.title = $event"
></text-document>
// 上面的代码，使用 .sync 就可以写成
<text-document v-bind:title.sync="doc.title"></text-document>
// 这样，在子组件中，就可以通过下面代码来实现对这个 prop 重新赋值的意图了。
this.$emit('update:title', newTitle)
```

#### v-model 和 .sync 对比

+ `.sync` 从功能上看和 `v-model` 十分相似，都是为了实现数据的“双向绑定”，本质上，也都不是真正的双向绑定，而是语法糖。
+ 相比较之下，`.sync` 更加灵活，它可以给多个 `prop` 使用，而 `v-model` 在一个组件中只能有一个。
+ 从语义上来看，`v-model` 绑定的值是指这个组件的绑定值，比如 input 组件，select 组件，日期时间选择组件，颜色选择器组件，这些组件所绑定的值使用 `v-model` 比较合适。其他情况，没有这种语义，个人认为使用 `.sync` 更好。

#### $parent 和 $children

+ `$parent` 属性可以用来从一个子组件访问父组件的实例，`$children` 属性 可以获取当前实例的直接子组件。
+ 看起来使用 `$parent` 比使用prop传值更加简单灵活，可以随时获取父组件的数据或方法，又不像使用 `prop` 那样需要提前定义好。但使用 `$parent` 会导致父组件数据变更后，很难去定位这个变更是从哪里发起的，所以在绝大多数情况下，不推荐使用。
+ 在有些场景下，两个组件之间可能是父子关系，也可能是更多层嵌套的祖孙关系,这时就可以使用 `$parent`。

#### **ref**

+ ref 特性可以为子组件赋予一个 ID 引用，通过这个 ID 引用可以直接访问这个子组件的实例。当父组件中需要主动获取子组件中的数据或者方法时，可以使用 `$ref` 来获取。
+ 使用 ref 时，有两点需要注意
  + `$refs` 是作为渲染结果被创建的，所以在初始渲染的时候它还不存在，此时无法无法访问。
  + `$refs` 不是响应式的，只能拿到获取它的那一刻子组件实例的状态，所以要避免在模板和计算属性中使用它。

### 非父子组件通信

#### eventBus

+ 对于比较小型的项目，没有必要引入 vuex 的情况下，可以使用 `eventBus`。相比我们上面说的所有通信方式，`eventBus` 可以实现任意两个组件间的通信。

+ 它的实现思想也很好理解，在要相互通信的两个组件中，都引入同一个新的vue实例，然后在两个组件中通过分别调用这个实例的事件触发和监听来实现通信。

  ```
  let Event = new Vue()
  Event.$emit('sayHello', 'hello');
  Event.$on('sayHello', target => {
      console.log(target);  // => 'hello'
  });
  ```

#### **$attrs 和 $listeners**

+ $attrs

+ `$attrs` 会包含父组件中没有被 `prop` 接收的所有属性（不包含class 和 style 属性），可以通过 `v-bind="$attrs"` 直接将这些属性传入内部组件。

  + 包含了父作用域中不作为prop被识别（且获取）的attribute绑定（class和style除外）
  + 当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定（class和style除外）
  + 并且可以通过v-bind="$attrs"传入内部组件——在创建高级别的组件时非常有用

+ $listeners

+ `$listeners` 会包含所有父组件中的 `v-on` 事件监听器 (不包含 `.native` 修饰器的) ，可以通过 `v-on="$listeners"` 传入内部组件

  + 包含了父作用域中的（不含.native修饰器的）v-on事件监听器。
  + 它可以通过v-on="$listeners"传入内部组件——在创建更高层次的组件时非常有用。

+ 当要和一个嵌套很深的组件进行通信时，如果使用 `prop` 和 `events` 就会显的十分繁琐，中间的组件只起到了一个中转站的作用，像下面这样：

  ```
  <!--父组件-->
    <parent-component :message="message">我是父组件</parent-component>
  <!--子组件-->
    <child-component :message="message">我是子组件</child-component>
  <!--孙子组件-->
    <grand-child-component :message="message">我是孙子组件</grand-child-component>
  ```

  

+ 当要传递的数据很多时，就需要在中间的每个组件都重复写很多遍，反过来从后代组件向祖先组件使用 events 传递也会有同样的问题。使用 `$attrs` 和 `$listeners` 就可以简化这样的写法。

#### **provide 和 inject**

+ `provide` 和 `inject` 需要在一起使用，它可以使一个祖先组件向其所有子孙后代注入一个依赖，可以指定想要提供给后代组件的数据/方法，不论组件层次有多深，都能够使用。

+ 不局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用

+ `provide` 和 `inject` 绑定不是响应的，它被设计是为组件库和高阶组件服务的，平常业务中的代码不建议使用。

  ```
  <!--祖先组件-->
  <script>
  export default {
      provide: {
          author: 'yushihu',
      },
      data() {},
  }
  </script>
  
  <!--子孙组件-->
  <script>
  export default {
      inject: ['author'],
      created() {
          console.log('author', this.author) // => yushihu
      },
  }
  </script>
  ```

  

#### **通过 $root 访问根实例**

+ 通过 `$root`，任何组件都可以获取当前组件树的根 Vue 实例，通过维护根实例上的 `data`，就可以实现组件间的数据共享。

```
//main.js 根实例
new Vue({
    el: '#app',
    store,
    router,
    // 根实例的 data 属性，维护通用的数据
    data: function () {
        return {
            author: ''
        }
    },
    components: { App },
    template: '<App/>',
});
<!--组件A-->
<script>
export default {
    created() {
        this.$root.author = '于是乎'
    }
}
</script>
<!--组件B-->
<template>
    <div><span>本文作者</span>{{ $root.author }}</div>
</template>
```

+ 通过这种方式，虽然可以实现通信，但在应用的任何部分，任何时间发生的任何数据变化，都不会留下变更的记录，这对于稍复杂的应用来说，调试是致命的，不建议在实际应用中使用。

#### **Vuex**

+ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。对一个中大型单页应用来说是不二之选。

+ 使用 Vuex 并不代表就要把所有的状态放入 Vuex 管理，这样做会让代码变的冗长，无法直观的看出要做什么。对于严格属于组件私有的状态还是应该在组件内部管理更好。

+ 简单的store模式

  ```
  //store.js
  var store = {
    debug: true,
    state: {
      author: 'yushihu!'
    },
    setAuthorAction (newValue) {
      if (this.debug) console.log('setAuthorAction triggered with', newValue)
      this.state.author = newValue
    },
    deleteAuthorAction () {
      if (this.debug) console.log('deleteAuthorAction triggered')
      this.state.author = ''
    }
  }
  ```

+ 和 Vuex 一样，store 中 `state` 的改变都由 store 内部的 `action` 来触发，并且能够通过 `log` 保留触发的痕迹。这种方式十分适合在不需要使用 Vuex 的小项目中应用。

+ 与 `$root` 访问根实例的方法相比，这种集中式状态管理的方式能够在调试过程中，通过 `log` 记录来确定当前变化是如何触发的，更容易定位问题。

### Vue路由原理

+ 根据不同的路径地址，展示不同的页面、组件
+ hash
  + hashchange

+ histroy
  + popstate

### Vuex

### Vuex是什么

+ Vuex是专门为Vuejs应用程序设计的**状态管理工具**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

### Vuex的构成

+ state
  + state是存储的单一状态，是存储的基本数据

+ Getters
  + getters是store的计算属性，对state的加工，是派生出来的数据。就想computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。

+ Mutations
  + Mutations提交更改数据，提交mutation，而不是直接改变状态（mutations同步函数）

+ Actions
  + actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）

+ Module
  + Moudule是store分割的模块，每个模块拥有自己的state、getters、mutations、actions

+ 辅助函数
  + Vuex提供了mapState、MapGetters、MapActions、mapMutations等辅助函数给开发在vm中处理store

### Vuex的设计思想

+ Vuex的设计思想，借鉴了Flux、Redux，将数据存放到全局的store，再将store挂载到每个vue实例组件中，利用Vue.js的细粒度数据响应机制来进行高效的状态更新。

### Vuex的原理解析



### Vuex和单纯的全局对象有什么区别

+ Vuex和全局对象主要有两大区别：
  - 1、Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
  - 2、不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

### 为什么 Vuex 的 mutation 中不能做异步操作

+ Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。
+ 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。



### vue-router

### vue-cli



### element ui

### vant

### cube

### SSR

### 优化

## React

### 基础知识

+ JSX语法（虚拟DOM）
+ 状态
+ 属性
+ ref
+ 组件
+ 生命周期
+ PureComponent
+ Hooks

### 核心原理

### react-router-dom

### redux

### react-redux

### dva

### umi

### mobix

### antd

### antd pro

### SSR

### 优化

## React Native

### 生命周期

+ 当应用启动，React Native框架在内存中维护着一个虚拟DOM树。所谓组件的生命周期即由组件初始化并挂载到虚拟DOM为起始，到组件由虚拟DOM卸载为终结，组件的不同状态。生命周期方法则是组件在虚拟DOM树不同状态的描述。

#### 初始化及挂载阶段

+ 这是组件类的构造函数，通常在此初始化state数据模型。

  ```
  constructor(props) {
    super(props);
    this.state = {
      //key : value
    };
  }
  ```

+ 表示组件将要加载到虚拟DOM，在render方法之前执行，整个生命周期只执行一次。

  ```javascript
  omponentWillMount() {
  
  }
  ```

+ 表示组件已经加载到虚拟DOM，在render方法之后执行，整个生命周期只执行一次。通常在该方法中完成异步网络请求或者集成其他JavaScript库。

  ```
  componentDidMount() {
  
  }
  ```

  

### 运行期阶段

+ 一、在组件接收到其父组件传递的`props`的时候执行,参数为父组件传递的`props`。在组件的整个生命周期可以多次执行。通常在此方法接收新的`props`值，重新设置`state`。

  ```
  componentWillReceiveProps(nextProps) {
    this.setState({
      //key : value
    });
  }
  ```

+ 二、在`componentWillReceiveProps(nextProps)`执行之后立刻执行；或者在`state`更改之后立刻执行。该方法包含两个参数，分别是`props`和`state`。该方法在组件的整个生命周期可以多次执行。如果该方法返回`false`，则`componentWillUpdate(nextProps, nextState)`及其之后执行的方法都不会执行，组件则不会进行重新渲染。

  ```javascript
  shouldComponentUpdate(nextProps, nextState) {
    return true;
  }
  ```

+ 三、在`shouldComponentUpdate(nextProps, nextState)`函数执行完毕之后立刻调用，该方法包含两个参数，分别是`props`和`state`。`render()`函数执行之前调用。该方法在组件的整个生命周期可以多次执行。

  ```
  componentWillUpdate(nextProps, nextState) {
  
  }
  ```

+ 四、在`render()`方法执行之后立刻调用。该方法包含两个参数，分别是`props`和`state`。该方法在组件的整个生命周期可以多次执行。

  ```
  componentDidUpdate(preProps, preState) {
  
  }
  ```

+ 五、`render`方法用于渲染组件。在初始化阶段和运行期阶段都会执行。

  ```
  render() {
    return(
      <View/>
    );
  }
  ```

  

### 卸载阶段

+ 在组件由虚拟DOM卸载的时候调用。

  ```
  componentWillUnmount() {
  
  }
  ```

# 算法



# TS



## 游戏方向

## 可视化或者AI方向

TS 代码 -> babel编译，webpack打包 -> 

JS 代码 -> 词法分析 -> 

抽象语法树AST -> 解释器 -> 

字节码 -> 编译器

汇编码 -> 执行