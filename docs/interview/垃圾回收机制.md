# 垃圾回收机制
## 如何识别垃圾 识别垃圾的几种方法
###  引用计数法
- 堆中的每个对象都有一个引用计数器。当一个对象被创造初始化赋值之后，该变量计数就设置为1
```
var a = new Object() // 计数变量 = 1
```
- 每当有一个地方引用它时，计数器的值就加1
```
var a = new Object() // 计数变量 = 1
var b = a   // 计数变量 + 1 = 2
```
当引用失效时，计数器的值就减1
```
var a = new Object() // 计数变量 = 1
var b = a   // 计数变量 + 1 = 2
var c = a   // 计数变量 + 1 = 3

a = null    // 引用失效，计数变量 -1 = 2
b = {}      // 引用失效，计数变量 -1 = 1
```
- 知识体系关联：这样的管理方式，类似于数组的 length 字段。
- 优点：引用计数收集器执行简单，实现简单，判定效率高，无延迟，对程序不被长时间打断的实时环境比较有利。
- 缺点：赋值时需要更新计数器，增加了微量时间开销，影响不大。最严重的问题是引用计数器无法处理循环引用的问题

``` js
var p = 
{ 
  n: 1, 
  next: {
   n: 2,
   next: p
  }
}

p = null
```
- 对象不可访问，计数也不为0，无法被回收，导致内存泄漏。

- 引用计数法虽然有这样致命的缺陷，但是由于其性能的优越性，依然有开发语言采用该算法，例如早期的 Java，以及现在的 Python。并通过手动解除、或者在循环引用的环节使用弱引用的方式。

### 根搜索算法 Tracing Collector
- 首先了解一个概念：GC Roots Set（根集），他是可访问的引用集合。Roots Set 中的引用变量可以用于访问对象的属性以及调用对象的方法。

- 这种算法的基本思路就是：先通过一系列 GC Roots 的对象作为起点，遍历寻找对应的引用节点。找到这些节点之后，继续向下递归寻找节点。

- 搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，就证明该对象是不可用的。

##### 哪些对象可以作为根节点：
- 所有正在运行的栈上的引用变量
- 所有的全局对象全局变量
- 所有的内置对象

- 在内存中对整个堆进行遍历，先从 GC 根对象开始，然后找到根对象引用的其它对象，能访问到的所有对象都标记为存活。

##### 关于标记阶段有几个关键点是值得注意的：
1.开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。这就是后面我们会提到的 stop-the-world
2.暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。
3.在 Blink 引擎的垃圾回收器 Oilpan 中，则某个对象在被回收之前，可能会执行一个回收之前需要做什么的生命周期函数 finalize。

- 如果该对象被判定为有必要执行 finalize() 方法，那么这个对象将会被放置在一个名为 finalization-queue 队列中，并在稍后由一条低优先级的 Finalizer 线程去执行这些任务。finalize 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 finalization-queue 中的对象进行第二次小规模的标记，如果要在 finalize() 中成功拯救自己，只要让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。

- 而在 V8 引擎的实现中，由于我们无法访问垃圾回收器，因此就没有提供这样的生命周期函数让 JavaScript 开发者有所作为。

4.GC 判断对象是否可达看的是强引用，而非弱引用

### V8 的垃圾回收器
- V8 的垃圾回收器名为 Orinoco。上面我们也提到，垃圾回收器无论在进行标记或者回收行为时，我们都会暂停 JS 主线程的执行。因此早期的 Orinoco 采用了这种 stop-the-world 的方式。
#### 任何垃圾收集器都有一些必须定期执行的基本任务：
1.识别活/死对象
2.回收/重用死对象占用的内存
3.压缩/碎片整理内存（可选）

- 这些任务可以按顺序执行，也可以任意交错执行。stop-the-world 的方式暂停 JavaScript 执行并在主线程上按顺序执行这些任务。当然这种方式的副作用就是会导致主线程出现卡顿和延迟，用户感知明显。