# 垃圾回收机制
## 如何识别垃圾 识别垃圾的几种方法
###  引用计数法
- 堆中的每个对象都有一个引用计数器。当一个对象被创造初始化赋值之后，该变量计数就设置为1
```
var a = new Object() // 计数变量 = 1
```
- 每当有一个地方引用它时，计数器的值就加1
```
var a = new Object() // 计数变量 = 1
var b = a   // 计数变量 + 1 = 2
```
当引用失效时，计数器的值就减1
```
var a = new Object() // 计数变量 = 1
var b = a   // 计数变量 + 1 = 2
var c = a   // 计数变量 + 1 = 3

a = null    // 引用失效，计数变量 -1 = 2
b = {}      // 引用失效，计数变量 -1 = 1
```
- 知识体系关联：这样的管理方式，类似于数组的 length 字段。
- 优点：引用计数收集器执行简单，实现简单，判定效率高，无延迟，对程序不被长时间打断的实时环境比较有利。
- 缺点：赋值时需要更新计数器，增加了微量时间开销，影响不大。最严重的问题是引用计数器无法处理循环引用的问题

``` js
var p = 
{ 
  n: 1, 
  next: {
   n: 2,
   next: p
  }
}

p = null
```
- 对象不可访问，计数也不为0，无法被回收，导致内存泄漏。

- 引用计数法虽然有这样致命的缺陷，但是由于其性能的优越性，依然有开发语言采用该算法，例如早期的 Java，以及现在的 Python。并通过手动解除、或者在循环引用的环节使用弱引用的方式。

### 根搜索算法 Tracing Collector
- 首先了解一个概念：GC Roots Set（根集），他是可访问的引用集合。Roots Set 中的引用变量可以用于访问对象的属性以及调用对象的方法。

- 这种算法的基本思路就是：先通过一系列 GC Roots 的对象作为起点，遍历寻找对应的引用节点。找到这些节点之后，继续向下递归寻找节点。

- 搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，就证明该对象是不可用的。