# 前端面试问题

## Event Loop

- **event loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。**

**宏队列和微队列**

- 宏队列，macrotask，也叫tasks。 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：
  + setTimeout
  + setInterval
  + setImmediate (Node独有)
  + requestAnimationFrame (浏览器独有)
  + I/O
  + UI rendering (浏览器独有)
- 微队列，microtask，也叫jobs。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：
  + process.nextTick (Node独有)
  + Promise
  + Object.observe
  + MutationObserver

**浏览器的Event Loop**

- **首先执行同步代码，同步代码全部执行完毕，执行微队列（microkask），直到全部执行完毕后再执行宏队列（macrokask）**

1. 执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；
2. 全局Script代码执行完毕后，调用栈Stack会清空；
3. 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；
4. 继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列1. 的末尾，也会在这个周期被调用执行；
5. microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；
6. 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；
7. 执行完毕后，调用栈Stack为空；
8. 重复第3-7个步骤；
9. 重复第3-7个步骤；

## HTTP 网络

### HTTP与HTTPS的区别

1. HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
2. HTTP 是不安全的，而 HTTPS 是安全的
3. HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
4. 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
5. HTTP 无法加密，而HTTPS 对传输的数据进行加密
6. HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书

### 什么是HTTP协议无状态协议?怎么解决HTTP协议无状态协议?

- **无状态协议对于事务处理没有记忆能力**。**缺少状态意味着如果后续处理需要前面的信息**
  - **也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。**
- **可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。**

### 常用的HTTP的方法

- GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

### HTTP请求报文与响应报文格式

- 请求报文
  + 请求行：包含请求方法、URI、HTTP版本信息
  + 请求首部字段
  + 请求内容实体
  + 空白行：用于通知服务器，客户端已经结束了该头的发送
- 响应报文
  - 状态行：包含HTTP版本、状态码、状态码的原因短语
  - 响应首部字段
  - 响应内容实体
  - 空白行：用于通知客户端，服务器已经结束了该头的发送
- 常见的首部
  + **通用首部字段（请求报文与响应报文都会使用的首部字段）**
    - Date：创建报文时间
    - Connection：连接的管理
    - Cache-Control：缓存的控制
    - Transfer-Encoding：报文主体的传输编码方式
  + **请求首部字段（请求报文会使用的首部字段）**
    - Host：请求资源所在服务器
    - Accept：可处理的媒体类型
    - Accept-Charset：可接收的字符集
    - Accept-Encoding：可接受的内容编码
    - Accept-Language：可接受的自然语言
  + **响应首部字段（响应报文会使用的首部字段）**
    - Accept-Ranges：可接受的字节范围
    - Location：令客户端重新定向到的URI
    - Server：HTTP服务器的安装信息
  + **实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）**
    - Allow：资源可支持的HTTP方法
    - Content-Type：实体主类的类型
    - Content-Encoding：实体主体适用的编码方式
    - Content-Language：实体主体的自然语言
    - Content-Length：实体主体的的字节数
    - Content-Range：实体主体的位置范围，一般用于发出部分请求时使用

### 一次完整的HTTP请求所经历的7个步骤

建立TCP连接->发送请求行->发送请求头->（到达服务器）发送状态行->发送响应头->发送响应数据->断TCP连接

- 建立TCP连接

在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。**HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。**

- Web浏览器向Web服务器发送请求行

一旦建立了TCP连接，**Web浏览器就会向Web服务器发送请求命令**。例如：GET /sample/hello.jsp HTTP/1.1。

- Web浏览器发送请求头
  - 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，**之后浏览器发送了一空白行来通知服务器**，它已经结束了该头信息的发送。
- Web服务器应答
  - 客户机向服务器发出请求后，服务器会客户机回送应答， **HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。**
- Web服务器发送应答头
  - 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。
- Web服务器向浏览器发送数据
  - Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，**它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据**。
- Web服务器关闭TCP连接
  - 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：

### 常见的HTTP相应状态码

- 200：请求被正常处理
- 204：请求被受理但没有资源可以返回
- 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
- 301：永久性重定向
- 302：临时重定向
- 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
- 304：发送附带条件的请求时，条件不满足时返回，与重定向无关
- 307：临时重定向，与302类似，只是强制要求使用POST方法
- 400：请求报文语法有误，服务器无法识别
- 401：请求需要认证
- 403：请求的对应资源禁止被访问
- 404：服务器无法找到对应资源
- 500：服务器内部错误
- 503：服务器正忙

### HTTP1.1版本新特性

- **默认持久连接节省通信量**，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求
- **管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应**
- **断点续传**
  - **实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。**

### HTTP优化方案

- **TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能**
- **内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。**
- **压缩：将文本数据进行压缩，减少带宽**
- **SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速**
- **TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。**

### 浏览器 & HTTP 缓存策略

#### 缓存策略

- 浏览器的缓存策略是依靠 HTTP Header 来实现的，共分为两种：
  + 强缓存
  + 协商缓存

#### 强缓存

- 强缓存是指在缓存期间，请求不会发送到服务器，浏览器直接返回缓存结果，需要设置 Header：

  - expires

    ```
    expires: Wed, 10 Oct 2020 09:51:00 GMT
    ```

    - expires 是 HTTP/1.0 中用于控制网页缓存的字段，其值代表服务器返回该请求结果的缓存到期时间，也就是说，再次发起同样的请求时，如果客户端时间小于 Expires 的值，浏览器直接返回缓存结果。
    - 由于 expires 是采用客户端时间去和缓存失效时间做对比，但客户端时间是可以做修改的，如果客户端时间和服务端时间并不同步，就会导致强缓存失效，或者时效变少。
    - 所以，在 HTTP/1.1 中增加了 cache-control 头。

  - Cache-Control

    - public：所有内容都将被缓存（客户端和代理服务器都可缓存）

    - private：所有内容只有客户端可以缓存，默认为 private

    - no-cache：客户端缓存内容，但是否使用缓存需要经过协商缓存来决定

    - no-store：所有内容都不会被缓存

    - max-age=xxx：缓存内容将在 xxx 秒之后失效

## 网络
1. 简述https原理，以及与http的区别
2. 操作系统中进程和线程怎么通信
3. 你知道哪些http头部
4. 怎么与服务端保持连接
5. http请求跨域问题，你都知道哪些解决跨域的方法
6. 你了解哪些请求方法，分别有哪些作用和不同
7. 浏览器缓存
8. jsonp实现一下跨域
9. 你知道哪些状态码
10. options请求方法有什么用

## 浏览器缓存

+ 浏览器缓存分为**强缓存**和**协商缓存**，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。
+ 控制强缓存的字段有：Expires 和 Cache-Control，Expires 和 Cache-Control。
+ 控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。


## Git

### git放弃修改，强制覆盖本地代码

```
git fetch --all
git reset --hard origin/master 
git pull
```

### git 合并多个commit

1. 查看提交历史git log

2. git rebase

   1. 从HEAD版本开始往过去数3个版本

      ```
      git rebase -i HEAD~3
      ```

   2. 指名要合并的版本之前的版本号

      ```
      git rebase -i 3a4226b
      ```

3. 选取要合并的提交

   1. 执行了rebase命令之后，会弹出一个窗口，头几行如下：

      ```
      pick 3ca6ec3   '注释**********'
      
      pick 1b40566   '注释*********'
      
      pick 53f244a   '注释**********'
      ```

   2. 将pick改为squash或者s,之后保存并关闭文本编辑窗口即可。改完之后文本内容如下：

      ```
      pick 3ca6ec3   '注释**********'
      
      s 1b40566   '注释*********'
      
      s 53f244a   '注释**********'
      ```

   3. 然后保存退出，Git会压缩提交历史，如果有冲突，需要修改，修改的时候要注意，保留最新的历史，不然我们的修改就丢弃了。修改以后要记得敲下面的命令：

      ```
      git add .  
      
      git rebase --continue  
      ```

      - 如果你想放弃这次压缩的话，执行以下命令：

      ```
      git rebase --abort  
      ```

4. 解决冲突

5. 输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了

### git merge和git rebase区别

#### git merge

- 会产生一个新的commit，如果合并时遇到冲突，仅需要修改后重新commit
- 优点：记录了真实的commit情况，包括每个分支的详情
- 缺点：每次merge会自动产生一个merge commit,commit比较频繁时，看到分支很杂乱

#### git rebase

- 本质是[变基](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA)
- 会合并之前的commit历史
- 优点：得到更简洁的项目历史，去掉了merge commit
- 缺点：如果合并出现代码问题不容易定位，因为re-write了history
- 合并时如果出现冲突需要按照如下步骤解决
  + 修改冲突部分
  + git add
  + git rebase --continue
  + （如果第三步无效可以执行  git rebase --skip）

