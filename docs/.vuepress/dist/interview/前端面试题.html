<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>阿木木的前端笔记</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/study-mu/logo.png">
    <meta name="description" content="阿木木的前端指南">
    <link rel="preload" href="/study-mu/assets/css/0.styles.cefe3876.css" as="style"><link rel="preload" href="/study-mu/assets/js/app.e89da039.js" as="script"><link rel="preload" href="/study-mu/assets/js/2.3e793b54.js" as="script"><link rel="preload" href="/study-mu/assets/js/35.c2301487.js" as="script"><link rel="prefetch" href="/study-mu/assets/js/10.654992a0.js"><link rel="prefetch" href="/study-mu/assets/js/11.6e7631b7.js"><link rel="prefetch" href="/study-mu/assets/js/12.b417c42b.js"><link rel="prefetch" href="/study-mu/assets/js/13.f324ecc1.js"><link rel="prefetch" href="/study-mu/assets/js/14.6b66a1f8.js"><link rel="prefetch" href="/study-mu/assets/js/15.08e1ad15.js"><link rel="prefetch" href="/study-mu/assets/js/16.b8c0cd0d.js"><link rel="prefetch" href="/study-mu/assets/js/17.7289a647.js"><link rel="prefetch" href="/study-mu/assets/js/18.1432740c.js"><link rel="prefetch" href="/study-mu/assets/js/19.ec2936aa.js"><link rel="prefetch" href="/study-mu/assets/js/20.b35b03b8.js"><link rel="prefetch" href="/study-mu/assets/js/21.3d00e894.js"><link rel="prefetch" href="/study-mu/assets/js/22.ef10c765.js"><link rel="prefetch" href="/study-mu/assets/js/23.20cb0347.js"><link rel="prefetch" href="/study-mu/assets/js/24.624b6ceb.js"><link rel="prefetch" href="/study-mu/assets/js/25.32c72bd3.js"><link rel="prefetch" href="/study-mu/assets/js/26.a58a6da9.js"><link rel="prefetch" href="/study-mu/assets/js/27.8020ef16.js"><link rel="prefetch" href="/study-mu/assets/js/28.54793955.js"><link rel="prefetch" href="/study-mu/assets/js/29.0141a256.js"><link rel="prefetch" href="/study-mu/assets/js/3.1b9b5c76.js"><link rel="prefetch" href="/study-mu/assets/js/30.ef073b03.js"><link rel="prefetch" href="/study-mu/assets/js/31.68d9419c.js"><link rel="prefetch" href="/study-mu/assets/js/32.b7bde630.js"><link rel="prefetch" href="/study-mu/assets/js/33.67a4e282.js"><link rel="prefetch" href="/study-mu/assets/js/34.4476ddeb.js"><link rel="prefetch" href="/study-mu/assets/js/36.3dea7003.js"><link rel="prefetch" href="/study-mu/assets/js/37.7c8074da.js"><link rel="prefetch" href="/study-mu/assets/js/38.abc556d1.js"><link rel="prefetch" href="/study-mu/assets/js/39.8a390b41.js"><link rel="prefetch" href="/study-mu/assets/js/4.5ed19beb.js"><link rel="prefetch" href="/study-mu/assets/js/40.c29a65df.js"><link rel="prefetch" href="/study-mu/assets/js/41.946f3e4e.js"><link rel="prefetch" href="/study-mu/assets/js/42.3155fca7.js"><link rel="prefetch" href="/study-mu/assets/js/43.05ec087f.js"><link rel="prefetch" href="/study-mu/assets/js/44.721dc17c.js"><link rel="prefetch" href="/study-mu/assets/js/45.9a7552d4.js"><link rel="prefetch" href="/study-mu/assets/js/46.d204b58c.js"><link rel="prefetch" href="/study-mu/assets/js/47.36a0d69d.js"><link rel="prefetch" href="/study-mu/assets/js/48.2837f850.js"><link rel="prefetch" href="/study-mu/assets/js/49.694812fb.js"><link rel="prefetch" href="/study-mu/assets/js/5.f634e961.js"><link rel="prefetch" href="/study-mu/assets/js/50.e3c123b6.js"><link rel="prefetch" href="/study-mu/assets/js/51.f2b8c948.js"><link rel="prefetch" href="/study-mu/assets/js/52.b69bfdce.js"><link rel="prefetch" href="/study-mu/assets/js/6.4554e8b1.js"><link rel="prefetch" href="/study-mu/assets/js/7.d25043f9.js"><link rel="prefetch" href="/study-mu/assets/js/8.d3ccc446.js"><link rel="prefetch" href="/study-mu/assets/js/9.d9ef5997.js">
    <link rel="stylesheet" href="/study-mu/assets/css/0.styles.cefe3876.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/study-mu/" class="home-link router-link-active"><img src="/study-mu/logo.png" alt="阿木木的前端笔记" class="logo"> <span class="site-name can-hide">阿木木的前端笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/study-mu/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/web/html/" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/web/css/" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/javaScript/js/" class="nav-link">
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/javaScript/es6/" class="nav-link">
  es6
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/frame/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/frame/react/" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="/study-mu/TypeScript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/study-mu/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/study-mu/http/" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/study-mu/arithmetic/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/study-mu/engineering/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/study-mu/interview/" class="nav-link router-link-active">
  面试问题
</a></div><div class="nav-item"><a href="/study-mu/knowledge/" class="nav-link">
  前端知识库
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/study-mu/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/web/html/" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/web/css/" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/javaScript/js/" class="nav-link">
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/javaScript/es6/" class="nav-link">
  es6
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/frame/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/frame/react/" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="/study-mu/TypeScript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/study-mu/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/study-mu/http/" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/study-mu/arithmetic/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/study-mu/engineering/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/study-mu/interview/" class="nav-link router-link-active">
  面试问题
</a></div><div class="nav-item"><a href="/study-mu/knowledge/" class="nav-link">
  前端知识库
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/study-mu/interview/" aria-current="page" class="sidebar-link">前端面试问题</a></li><li><a href="/study-mu/interview/html.html" class="sidebar-link">Html 面试题</a></li><li><a href="/study-mu/interview/css.html" class="sidebar-link">Css 面试题</a></li><li><a href="/study-mu/interview/js.html" class="sidebar-link">js基础面试题</a></li><li><a href="/study-mu/interview/jsHigh.html" class="sidebar-link">JS高频面试题</a></li><li><a href="/study-mu/interview/es6.html" class="sidebar-link">es6基础面试题</a></li><li><a href="/study-mu/interview/TypeScript.html" class="sidebar-link">typescript</a></li><li><a href="/study-mu/interview/vue.html" class="sidebar-link">VUE</a></li><li><a href="/study-mu/interview/react.html" class="sidebar-link">React</a></li><li><a href="/study-mu/interview/node.html" class="sidebar-link">Node</a></li><li><a href="/study-mu/interview/arithmetic.html" class="sidebar-link">算法</a></li><li><a href="/study-mu/interview/performance.html" class="sidebar-link">模块化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>前端面试题</p> <h2 id="html"><a href="#html" class="header-anchor">#</a> HTML</h2> <h3 id="html5语义化"><a href="#html5语义化" class="header-anchor">#</a> HTML5语义化</h3> <ul><li>用合理、正确的标签来展示</li> <li>好处：
<ul><li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</li> <li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li> <li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li> <li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。</li></ul></li></ul> <h3 id="reflow和repaint"><a href="#reflow和repaint" class="header-anchor">#</a> Reflow和Repaint</h3> <ul><li>Reflow：当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。</li> <li>Repaint：当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。</li> <li>引起重排和重绘的操作
<ul><li>调整窗口大小</li> <li>字体大下改变</li> <li>样式表变动</li> <li>元素内容变化，尤其是输入控件</li> <li>CSS伪类激活，在用户交互过程中发生</li> <li>DOM操作，DOM元素增删、修改</li> <li>width, clientWidth, scrollTop等布局宽高的计算</li></ul></li> <li>优化建议
<ul><li>避免逐条更改样式。建议集中修改样式，例如操作className。</li> <li>避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置display:none的元素上操作，最后显示出来。</li> <li>避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。</li> <li>绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流</li></ul></li></ul> <h3 id="href和src的区别"><a href="#href和src的区别" class="header-anchor">#</a> href和src的区别</h3> <ul><li><strong>href</strong>：href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系。若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。</li> <li><strong>src</strong>：src表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。
当浏览器解析到src ，会暂停其他资源的下载和处理（图片不会暂停其他资源下载和处理），直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</li></ul> <h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="header-anchor">#</a> 浏览器的渲染过程</h3> <ol><li>解析HTML文本并构建DOM tree</li> <li>解析CSS样式表并构建CSSOM tree</li> <li>根据DOM tree 和 CSSOM tree 构建 Render tree</li> <li>根据Render tree信息进行布局处理（Layout）</li> <li>对页面元素进行绘制（Painting）</li></ol> <h3 id="从输入-url-到页面加载完成的过程中都发生了什么"><a href="#从输入-url-到页面加载完成的过程中都发生了什么" class="header-anchor">#</a> 从输入 URL 到页面加载完成的过程中都发生了什么？</h3> <ol><li>键盘或触屏输入URL并回车确认</li> <li>URL解析/DNS解析查找域名IP地址</li> <li>网络连接发起HTTP请求</li> <li>HTTP报文传输过程</li> <li>服务器接收数据</li> <li>服务器响应请求/MVC</li> <li>服务器返回数据</li> <li>客户端接收数据</li> <li>浏览器加载/渲染页面</li> <li>打印绘制输出</li></ol> <h3 id="doctype有什么作用"><a href="#doctype有什么作用" class="header-anchor">#</a> doctype有什么作用</h3> <ul><li><p>doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。</p> <p>声明是用来指示web浏览器关于页面使用哪个HTML版本进行编写的指令。 声明必须是HTML文档的第一行，位于html标签之前。</p> <p>浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过doctype来区分这两种模式，doctype在html中的作用就是触发浏览器的标准模式，如果html中省略了doctype，浏览器就会进入到Quirks模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而html标准和dom标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在html开头使用doctype。</p></li></ul> <h3 id="iframe框架有那些优缺点"><a href="#iframe框架有那些优缺点" class="header-anchor">#</a> iframe框架有那些优缺点</h3> <p><strong>优点：</strong></p> <ul><li>iframe能够原封不动的把嵌入的网页展现出来。</li> <li>如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li> <li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。</li> <li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。</li></ul> <p><strong>缺点：</strong></p> <ul><li>搜索引擎的爬虫程序无法解读这种页面</li> <li>框架结构中出现各种滚动条</li> <li>使用框架结构时，保证设置正确的导航链接。</li> <li>iframe页面会增加服务器的http请求</li></ul> <h3 id="label标签的作用"><a href="#label标签的作用" class="header-anchor">#</a> label标签的作用</h3> <ul><li><p>通常是写在表单内，它关联一个控件，使用 <code>label</code> 可以实现点击文字选取对应的控件。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>checkbox<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>test<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>test<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ul> <h3 id="关闭form自动完成功能"><a href="#关闭form自动完成功能" class="header-anchor">#</a> 关闭form自动完成功能</h3> <ul><li>设置 <code>autocomplete=off</code></li></ul> <h3 id="content-type"><a href="#content-type" class="header-anchor">#</a> content-type</h3> <ul><li>Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。</li></ul> <h2 id="css"><a href="#css" class="header-anchor">#</a> CSS</h2> <p><a href="https://github.com/woai3c/Front-end-basic-knowledge/blob/master/CSS.md" target="_blank" rel="noopener noreferrer">github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h2> <p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md" target="_blank" rel="noopener noreferrer">面试题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="js运行机制"><a href="#js运行机制" class="header-anchor">#</a> JS运行机制</h3> <ul><li>关键词: 单线程 =&gt; 同步任务和异步任务</li> <li>同步任务在主线程上执行，形成一个执行栈</li> <li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件</li> <li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行</li></ul> <h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="header-anchor">#</a> 变量提升和函数提升</h3> <ul><li><p>函数优先。函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量</p></li> <li><p>实例</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token keyword">var</span> foo<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>会被引擎解析诚如下代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>注意，var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明(因此被忽 略了)，因为函数声明会被提升到普通变量之前。</p></li></ul> <h3 id="promise原理"><a href="#promise原理" class="header-anchor">#</a> Promise原理</h3> <ul><li>三种状态: 等待态(Pending)、执行态（Fulfilled）、拒绝态（Pejected）</li></ul> <h3 id="防抖和节流"><a href="#防抖和节流" class="header-anchor">#</a> 防抖和节流</h3> <ol><li>防抖：在事件被触发N秒后在执行回调，如果在这N秒内又被触发，则重新计时
<ul><li>实现思路：通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了。</li></ul></li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> interval <span class="token operator">=</span> <span class="token number">300</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">scroll</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span>
window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span>scroll<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>节流：规定一个单位时间，在这个单位时间内，只能执行一次回调，如果触发了多次，只有一次生效
<ul><li>实现思路: 函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉。</li></ul></li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> interval <span class="token operator">=</span> <span class="token number">300</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> canRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>canRun<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        canRun <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
            canRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="header-anchor">#</a> 深拷贝和浅拷贝</h3> <ul><li>浅拷贝
<ul><li>浅拷贝就是拷贝指向对象的指针,意思就是说:拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间.</li> <li>浅拷贝只是一种简单的拷贝,让几个对象公用一个内存,然而当内存销毁的时候,指向这个内存空间的所有指针需要重新定义,不然会造成野指针错误</li></ul></li> <li>深拷贝
<ul><li>所谓的深拷贝指拷贝对象的具体内容,其内容地址是自助分配的,拷贝结束之后,内存中的值是完全相同的,但是内存地址是不一样的,两个对象之间相互不影响,也互不干涉.</li></ul></li></ul> <h3 id="bind、call、apply"><a href="#bind、call、apply" class="header-anchor">#</a> bind、call、apply</h3> <ul><li>第一个参数都是改变this的上下文，改变this指向</li> <li>bind：改变this指向，但不会马上执行，而是返回一个函数</li> <li>call：第二个参数开始以参数列表的形式展现</li> <li>apply: 第二个参数接受一个数组</li></ul> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await</h3> <ul><li><p><code>async/await</code>实际上是<code>Generator</code>的语法糖。顾名思义，<code>async</code>关键字代表后面的函数中有异步操作，<code>await</code>表示等待一个异步方法执行完成。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async function is running!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> num1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">200</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">num1 is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>num1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> num2 <span class="token operator">=</span> <span class="token keyword">await</span> num1<span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">num2 is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>num2<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> num3 <span class="token operator">=</span> <span class="token keyword">await</span> num2 <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">num3 is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>num3<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'run me before await!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// async function is running!</span>
<span class="token comment">// run me before await!</span>
<span class="token comment">// num1 is 200</span>
<span class="token comment">// num2 is 300</span>
<span class="token comment">// num3 is 400</span>
</code></pre></div></li> <li><p>错误捕获</p> <ul><li>try/catch</li> <li>Promise.then</li></ul></li></ul> <h3 id="array方法"><a href="#array方法" class="header-anchor">#</a> Array方法</h3> <ul><li><p>some: 测试是否至少有一个元素可以通过被提供的函数方法。返回布尔值</p></li> <li><p>every: 测试一个数组内的所有元素是否都能通过某个指定函数的方法。返回布尔值</p></li> <li><p>reduce: 对数组中的每一个元素执行一个由您提供的reduce函数，将其结果汇总为单个返回值</p></li> <li><p>flat: 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p> <ul><li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr1<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// [1, 2, 3, 4]</span>

<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr2<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [1, 2, 3, 4, [5, 6]]</span>

<span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr3<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [1, 2, 3, 4, 5, 6]</span>

<span class="token comment">//使用 Infinity 作为深度，展开任意深度的嵌套数组</span>
arr3<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// [1, 2, 3, 4, 5, 6]</span>
</code></pre></div></li></ul></li></ul> <h3 id="原型和原型链"><a href="#原型和原型链" class="header-anchor">#</a> 原型和原型链</h3> <ul><li><p><a href="https://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="noopener noreferrer">详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>所有函数对象的 <strong>proto</strong> 都指向 Function.prototype，它是一个空函数（Empty function）</p></li> <li><p>所有对象的 <strong>proto</strong> 都指向其构造器的 prototype</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jack'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div></li> <li><p>实例对象的内部原型总是指向其构造器的原型对象prototype</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jack'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> p<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div></li> <li><p>Function.prototype.<strong>proto</strong> === Object.prototype //true</p></li> <li><p><code>Object.prototype.__proto__ === null</code>，保证原型链能够正常结束</p></li></ul> <h3 id="class-extends-super"><a href="#class-extends-super" class="header-anchor">#</a> class, extends, super</h3> <ul><li>class: 创建一个带有作用域的对象</li> <li>extends: class可以通过extends实现继承</li> <li>super: 表示父类的构造函数，用来新建父类的this对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  class Point {
  }

  class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y); // 调用父类的constructor(x, y)
        this.color = color;
    }

    toString() {
        return this.color + ' ' + super.toString(); // 调用父类的toString()
    }
  }
</code></pre></div><h3 id="cookie-localstorage-sessionstorage"><a href="#cookie-localstorage-sessionstorage" class="header-anchor">#</a> Cookie,LocalStorage,SessionStorage</h3> <table><thead><tr><th>特性</th> <th>Cookie</th> <th>LocalStorage</th> <th>SessionStorage</th></tr></thead> <tbody><tr><td>数据的生命期</td> <td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td> <td>除非被清除，否则永久保存</td> <td>仅在当前会话下有效，关闭页面或浏览器后被清除</td></tr> <tr><td>存放数据大小</td> <td>4K左右</td> <td>一般为5MB</td> <td></td></tr> <tr><td>与服务器端通信</td> <td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td> <td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td> <td></td></tr> <tr><td>易用性</td> <td>需要程序员自己封装，源生的Cookie接口不友好</td> <td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td> <td></td></tr></tbody></table> <h3 id="阻塞渲染-css-与-javascript"><a href="#阻塞渲染-css-与-javascript" class="header-anchor">#</a> 阻塞渲染：CSS 与 JavaScript</h3> <p><strong>css</strong></p> <ul><li>CSS被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。</li> <li>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。</li> <li>CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt; p { color: red; }&lt;/style&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;
</code></pre></div><ul><li>这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;
&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 30em) and (orientation: landscape)&quot;&gt;
</code></pre></div><ul><li>第一个资源会加载并阻塞。</li> <li>第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。</li> <li>第三个资源提供了媒体查询，会在符合条件时阻塞渲染。</li></ul> <p><strong>JavaScript</strong></p> <ul><li>当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。</li></ul> <h3 id="改变阻塞模式-defer-与-async"><a href="#改变阻塞模式-defer-与-async" class="header-anchor">#</a> 改变阻塞模式：defer 与 async</h3> <p><strong>defer</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src=&quot;app1.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;app2.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;app3.js&quot; defer&gt;&lt;/script&gt;
</code></pre></div><ul><li>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</li> <li>defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。</li></ul> <p><strong>async</strong></p> <div class="language- extra-class"><pre class="language-text"><code>script src=&quot;app.js&quot; async&gt;&lt;/script&gt;
&lt;script src=&quot;ad.js&quot; async&gt;&lt;/script&gt;
&lt;script src=&quot;statistics.js&quot; async&gt;&lt;/script&gt;
</code></pre></div><ul><li>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。</li></ul> <h3 id="对象到字符串的转换步骤"><a href="#对象到字符串的转换步骤" class="header-anchor">#</a> 对象到字符串的转换步骤</h3> <ol><li>如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果</li> <li>如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果</li> <li>否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError</li></ol> <h3 id="函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组"><a href="#函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组" class="header-anchor">#</a> 函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组</h3> <ul><li>arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参</li> <li>arguments.length为实参的个数（Function.length表示形参长度）</li> <li>arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化</li> <li>转换为数组：var args = Array.prototype.slice.call(arguments, 0);</li></ul> <h3 id="评价一下三种方法实现继承的优缺点-并改进"><a href="#评价一下三种方法实现继承的优缺点-并改进" class="header-anchor">#</a> 评价一下三种方法实现继承的优缺点,并改进</h3> <div class="language- extra-class"><pre class="language-text"><code>function Shape() {}

function Rect() {}

// 方法1 原型继承
Rect.prototype = new Shape();

// 方法2 原型链继承
Rect.prototype = Shape.prototype;

// 方法3 混合方式继承
Rect.prototype = Object.create(Shape.prototype);

Rect.prototype.area = function () {
  // do something
};
</code></pre></div><p><strong>方法1：原型继承</strong></p> <ul><li>优点：正确设置原型链实现继承</li> <li>优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值</li> <li>缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改</li> <li>缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置</li> <li>总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化</li></ul> <p><strong>方法2：原型链继承</strong></p> <ul><li>优点：正确设置原型链实现继承</li> <li>缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类</li></ul> <p><strong>方法3：</strong></p> <ul><li>优点：正确设置原型链且避免方法1.2中的缺点</li> <li>缺点：ES5方法需要注意兼容性</li></ul> <p><strong>改进：</strong></p> <ul><li>所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Rect() {
    Shape.call(this);
}
</code></pre></div><ul><li>用新创建的对象替代子类默认原型，设置Rect.prototype.constructor = Rect;保证一致性</li> <li>第三种方法的polyfill：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function create(obj) {
    if (Object.create) {
        return Object.create(obj);
    }

    function f() {};
    f.prototype = obj;
    return new f();
}
</code></pre></div><p><strong>方法4： Class,extends继承</strong></p> <div class="language- extra-class"><pre class="language-text"><code>class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y);    this.color = color; // 正确
  }
}
</code></pre></div><h3 id="什么是闭包-闭包的作用"><a href="#什么是闭包-闭包的作用" class="header-anchor">#</a> 什么是闭包，闭包的作用</h3> <ul><li>闭包是一个函数，能将创建的变量的值始终保持在内存中，以供本地环境使用。</li> <li>函数内部可以直接访问外部变量，但在函数外部无法访问函数内部变量。使用闭包的主要作用就是间接访问函数的内部数据。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function showNum() {
  var num = 12;
  function showNum2() {
    console.log(num);
  };
  return showNum2;
}
var myNum = showNum();
myNum();//12
</code></pre></div><ul><li>将创建的变量的值始终保持在内存中，以供本地环境使用。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function showNum() {
  var num = 12;
  function showNum2() {
    console.log(++num);
  };
  return showNum2;
}
var myNum = showNum();
myNum();//13
</code></pre></div><h3 id="event-loop"><a href="#event-loop" class="header-anchor">#</a> Event Loop</h3> <ul><li><strong>event loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。</strong></li></ul> <p><strong>宏队列和微队列</strong></p> <ul><li>宏队列，macrotask，也叫tasks。 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：
<ul><li>setTimeout</li> <li>setInterval</li> <li>setImmediate (Node独有)</li> <li>requestAnimationFrame (浏览器独有)</li> <li>I/O</li> <li>UI rendering (浏览器独有)</li></ul></li> <li>微队列，microtask，也叫jobs。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：
<ul><li>process.nextTick (Node独有)</li> <li>Promise</li> <li>Object.observe</li> <li>MutationObserver</li></ul></li></ul> <p><strong>浏览器的Event Loop</strong></p> <ul><li><strong>首先执行同步代码，同步代码全部执行完毕，执行微队列（microkask），直到全部执行完毕后再执行宏队列（macrokask）</strong></li></ul> <ol><li>执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</li> <li>全局Script代码执行完毕后，调用栈Stack会清空；</li> <li>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</li> <li>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列1. 的末尾，也会在这个周期被调用执行；</li> <li>microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</li> <li>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</li> <li>执行完毕后，调用栈Stack为空；</li> <li>重复第3-7个步骤；</li> <li>重复第3-7个步骤；</li></ol> <h3 id="箭头函数和普通函数有什么区别"><a href="#箭头函数和普通函数有什么区别" class="header-anchor">#</a> 箭头函数和普通函数有什么区别</h3> <ul><li>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象，用call，apply，bind也不能改变this指向</li> <li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li> <li>箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li> <li>箭头函数不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li> <li>箭头函数没有原型对象prototype</li></ul> <h3 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h3> <ul><li>sort</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> a<span class="token operator">-</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>冒泡排序</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">var</span> c <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>    
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><a href="https://blog.csdn.net/lianwenxiu/article/details/88087176" target="_blank" rel="noopener noreferrer">查看更多<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="javascript内存机制之问-数据是如何存储的"><a href="#javascript内存机制之问-数据是如何存储的" class="header-anchor">#</a> JavaScript内存机制之问——数据是如何存储的？</h3> <ul><li>基本数据类型用栈存储，引用数据类型用堆存储。（闭包变量是存在堆内存中的。）</li> <li>基本数据类型：boolean string number null undefined symbol bigint</li> <li>引用数据类型：object function array</li></ul> <h3 id="js异步编程有哪些方案-为什么会出现这些方案"><a href="#js异步编程有哪些方案-为什么会出现这些方案" class="header-anchor">#</a> JS异步编程有哪些方案？为什么会出现这些方案？</h3> <h4 id="回调函数"><a href="#回调函数" class="header-anchor">#</a> 回调函数</h4> <ul><li>很容易产生回调地狱。代码可读性和可维护性差，每次任务可能会失败，需要在回调里面对每个任务的失败情况进行处理，增加了代码的混乱程度。</li></ul> <h4 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h4> <ul><li>解决了回调地狱，增加了代码可读性</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>
<span class="token keyword">const</span> <span class="token constant">REJECT</span> <span class="token operator">=</span> <span class="token string">'reject'</span>

<span class="token keyword">function</span> <span class="token function">MyPromise</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span>
    self<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span>
    self<span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token keyword">null</span>
    self<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">PENDING</span>
    self<span class="token punctuation">.</span>onFulfilled <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//成功的回调函数</span>
    self<span class="token punctuation">.</span>onRejected <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//失败的回调函数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            self<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span><span class="token punctuation">;</span>
            self<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            self<span class="token punctuation">.</span><span class="token function">onFulfilled</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//resolve时执行成功回调</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            self<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECT</span><span class="token punctuation">;</span>
            self<span class="token punctuation">.</span>error <span class="token operator">=</span> error<span class="token punctuation">;</span>
            self<span class="token punctuation">.</span><span class="token function">onRejected</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//reject时执行失败回调</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">MyPromise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilled <span class="token operator">=</span> onFulfilled<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>onRejected <span class="token operator">=</span> onRejected<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//如果状态是fulfilled，直接执行成功回调，并将成功值传入</span>
    <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">//如果状态是rejected，直接执行失败回调，并将失败原因传入</span>
    <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>error<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="async-await-2"><a href="#async-await-2" class="header-anchor">#</a> async + await</h4> <ul><li><p>ES7新增，加上 async 的函数都默认返回一个 Promise 对象</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">readFileAsync</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> f1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFilePromise</span><span class="token punctuation">(</span><span class="token string">'1.json'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> f2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFilePromise</span><span class="token punctuation">(</span><span class="token string">'2.json'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> f3 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFilePromise</span><span class="token punctuation">(</span><span class="token string">'3.json'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> f4 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFilePromise</span><span class="token punctuation">(</span><span class="token string">'4.json'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="require和import"><a href="#require和import" class="header-anchor">#</a> require和import</h3> <ul><li><p>require：运行时调用；使用module.exports导出</p></li> <li><p>import：编译时调用，必须放在文件开头引入</p> <ul><li>export和import</li> <li>export：用于对外输出本模块（一个文件可以理解为一个模块）变量的接口</li> <li>import：用于在一个模块中加载export输出变量的接口</li></ul></li> <li><p>require/exports 和 import/export 形式不一样</p> <p>require/exports 的写法：</p> <div class="language-text extra-class"><pre class="language-text"><code>const fs = require('fs')
exports.fs = fs
module.exports = fs
</code></pre></div><p>import/export 的写法：</p> <div class="language-text extra-class"><pre class="language-text"><code>import fs from 'fs'
import {default as fs} from 'fs'
import * as fs from 'fs'
import {readFile} from 'fs'
import {readFile as read} from 'fs'
import fs, {readFile} from 'fs'

export default fs
export const fs
export function readFile
export {readFile, read}
export * from 'fs'
</code></pre></div></li></ul> <h2 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h2> <h3 id="http与https的区别"><a href="#http与https的区别" class="header-anchor">#</a> HTTP与HTTPS的区别</h3> <ol><li>HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头</li> <li>HTTP 是不安全的，而 HTTPS 是安全的</li> <li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li> <li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li> <li>HTTP 无法加密，而HTTPS 对传输的数据进行加密</li> <li>HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书</li></ol> <h3 id="什么是http协议无状态协议-怎么解决http协议无状态协议"><a href="#什么是http协议无状态协议-怎么解决http协议无状态协议" class="header-anchor">#</a> 什么是HTTP协议无状态协议?怎么解决HTTP协议无状态协议?</h3> <ul><li><strong>无状态协议对于事务处理没有记忆能力</strong>。<strong>缺少状态意味着如果后续处理需要前面的信息</strong> <ul><li><strong>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</strong></li></ul></li> <li><strong>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。</strong></li></ul> <h3 id="常用的http的方法"><a href="#常用的http的方法" class="header-anchor">#</a> 常用的HTTP的方法</h3> <ul><li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li> <li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li> <li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li> <li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li> <li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li> <li>OPTIONS：查询相应URI支持的HTTP方法。</li></ul> <h3 id="http请求报文与响应报文格式"><a href="#http请求报文与响应报文格式" class="header-anchor">#</a> HTTP请求报文与响应报文格式</h3> <ul><li>请求报文
<ul><li>请求行：包含请求方法、URI、HTTP版本信息</li> <li>请求首部字段</li> <li>请求内容实体</li> <li>空白行：用于通知服务器，客户端已经结束了该头的发送</li></ul></li> <li>响应报文
<ul><li>状态行：包含HTTP版本、状态码、状态码的原因短语</li> <li>响应首部字段</li> <li>响应内容实体</li> <li>空白行：用于通知客户端，服务器已经结束了该头的发送</li></ul></li> <li>常见的首部
<ul><li><strong>通用首部字段（请求报文与响应报文都会使用的首部字段）</strong> <ul><li>Date：创建报文时间</li> <li>Connection：连接的管理</li> <li>Cache-Control：缓存的控制</li> <li>Transfer-Encoding：报文主体的传输编码方式</li></ul></li> <li><strong>请求首部字段（请求报文会使用的首部字段）</strong> <ul><li>Host：请求资源所在服务器</li> <li>Accept：可处理的媒体类型</li> <li>Accept-Charset：可接收的字符集</li> <li>Accept-Encoding：可接受的内容编码</li> <li>Accept-Language：可接受的自然语言</li></ul></li> <li><strong>响应首部字段（响应报文会使用的首部字段）</strong> <ul><li>Accept-Ranges：可接受的字节范围</li> <li>Location：令客户端重新定向到的URI</li> <li>Server：HTTP服务器的安装信息</li></ul></li> <li><strong>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</strong> <ul><li>Allow：资源可支持的HTTP方法</li> <li>Content-Type：实体主类的类型</li> <li>Content-Encoding：实体主体适用的编码方式</li> <li>Content-Language：实体主体的自然语言</li> <li>Content-Length：实体主体的的字节数</li> <li>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</li></ul></li></ul></li></ul> <h3 id="一次完整的http请求所经历的7个步骤"><a href="#一次完整的http请求所经历的7个步骤" class="header-anchor">#</a> 一次完整的HTTP请求所经历的7个步骤</h3> <p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p> <ul><li>建立TCP连接</li></ul> <p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。<strong>HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</strong></p> <ul><li>Web浏览器向Web服务器发送请求行</li></ul> <p>一旦建立了TCP连接，<strong>Web浏览器就会向Web服务器发送请求命令</strong>。例如：GET /sample/hello.jsp HTTP/1.1。</p> <ul><li>Web浏览器发送请求头
<ul><li>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，<strong>之后浏览器发送了一空白行来通知服务器</strong>，它已经结束了该头信息的发送。</li></ul></li> <li>Web服务器应答
<ul><li>客户机向服务器发出请求后，服务器会客户机回送应答， <strong>HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</strong></li></ul></li> <li>Web服务器发送应答头
<ul><li>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</li></ul></li> <li>Web服务器向浏览器发送数据
<ul><li>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，<strong>它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</strong>。</li></ul></li> <li>Web服务器关闭TCP连接
<ul><li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</li></ul></li></ul> <h3 id="常见的http相应状态码"><a href="#常见的http相应状态码" class="header-anchor">#</a> 常见的HTTP相应状态码</h3> <ul><li>200：请求被正常处理</li> <li>204：请求被受理但没有资源可以返回</li> <li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li> <li>301：永久性重定向</li> <li>302：临时重定向</li> <li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li> <li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li> <li>307：临时重定向，与302类似，只是强制要求使用POST方法</li> <li>400：请求报文语法有误，服务器无法识别</li> <li>401：请求需要认证</li> <li>403：请求的对应资源禁止被访问</li> <li>404：服务器无法找到对应资源</li> <li>500：服务器内部错误</li> <li>503：服务器正忙</li></ul> <h3 id="http1-1版本新特性"><a href="#http1-1版本新特性" class="header-anchor">#</a> HTTP1.1版本新特性</h3> <ul><li><strong>默认持久连接节省通信量</strong>，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li> <li><strong>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</strong></li> <li><strong>断点续传</strong> <ul><li><strong>实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。</strong></li></ul></li></ul> <h3 id="http优化方案"><a href="#http优化方案" class="header-anchor">#</a> HTTP优化方案</h3> <ul><li><strong>TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能</strong></li> <li><strong>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。</strong></li> <li><strong>压缩：将文本数据进行压缩，减少带宽</strong></li> <li><strong>SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速</strong></li> <li><strong>TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。</strong></li></ul> <h3 id="浏览器-http-缓存策略"><a href="#浏览器-http-缓存策略" class="header-anchor">#</a> 浏览器 &amp; HTTP 缓存策略</h3> <h4 id="缓存策略"><a href="#缓存策略" class="header-anchor">#</a> 缓存策略</h4> <ul><li>浏览器的缓存策略是依靠 HTTP Header 来实现的，共分为两种：
<ul><li>强缓存</li> <li>协商缓存</li></ul></li></ul> <h4 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h4> <ul><li><p>强缓存是指在缓存期间，请求不会发送到服务器，浏览器直接返回缓存结果，需要设置 Header：</p> <ul><li><p>expires</p> <div class="language- extra-class"><pre class="language-text"><code>expires: Wed, 10 Oct 2020 09:51:00 GMT
</code></pre></div><ul><li>expires 是 HTTP/1.0 中用于控制网页缓存的字段，其值代表服务器返回该请求结果的缓存到期时间，也就是说，再次发起同样的请求时，如果客户端时间小于 Expires 的值，浏览器直接返回缓存结果。</li> <li>由于 expires 是采用客户端时间去和缓存失效时间做对比，但客户端时间是可以做修改的，如果客户端时间和服务端时间并不同步，就会导致强缓存失效，或者时效变少。</li> <li>所以，在 HTTP/1.1 中增加了 cache-control 头。</li></ul></li> <li><p>Cache-Control</p> <ul><li><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</p></li> <li><p>private：所有内容只有客户端可以缓存，默认为 private</p></li> <li><p>no-cache：客户端缓存内容，但是否使用缓存需要经过协商缓存来决定</p></li> <li><p>no-store：所有内容都不会被缓存</p></li> <li><p>max-age=xxx：缓存内容将在 xxx 秒之后失效</p></li></ul></li></ul></li></ul> <h2 id="主流框架"><a href="#主流框架" class="header-anchor">#</a> 主流框架</h2> <h3 id="react-vue为什么要在列表组件中写key-作用是什么"><a href="#react-vue为什么要在列表组件中写key-作用是什么" class="header-anchor">#</a> React/Vue为什么要在列表组件中写key,作用是什么？</h3> <ul><li><p>key是给每一个vnode(虚拟dom)的唯一id,可以依靠 key ，更<strong>准确</strong>，更<strong>快</strong>的拿到oldVnode中对应的vnode节点。</p></li> <li><p><strong>更准确</strong></p> <p>因为有key的存在，避免了就地复用，a.key === b.key的对比中，避免了就地复用情况。</p></li> <li><p><strong>更快</strong></p> <p>利用key的唯一=key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。</p></li></ul> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <h3 id="purecomponent-vs-component"><a href="#purecomponent-vs-component" class="header-anchor">#</a> PureComponent Vs Component</h3> <ul><li>PureComponent通过prop和state的浅比较来实现shouldComponentUpdate，某些情况下可以用PureComponent提升性能</li> <li>PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件</li> <li>若是数组和对象等引用类型，则要引用不同，才会渲染</li> <li>如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间</li> <li>若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较</li></ul> <h2 id="git"><a href="#git" class="header-anchor">#</a> Git</h2> <h3 id="git放弃修改-强制覆盖本地代码"><a href="#git放弃修改-强制覆盖本地代码" class="header-anchor">#</a> git放弃修改，强制覆盖本地代码</h3> <div class="language- extra-class"><pre class="language-text"><code>git fetch --all
git reset --hard origin/master 
git pull
</code></pre></div><h3 id="git-合并多个commit"><a href="#git-合并多个commit" class="header-anchor">#</a> git 合并多个commit</h3> <ol><li><p>查看提交历史git log</p></li> <li><p>git rebase</p> <ol><li><p>从HEAD版本开始往过去数3个版本</p> <div class="language- extra-class"><pre class="language-text"><code>git rebase -i HEAD~3
</code></pre></div></li> <li><p>指名要合并的版本之前的版本号</p> <div class="language- extra-class"><pre class="language-text"><code>git rebase -i 3a4226b
</code></pre></div></li></ol></li> <li><p>选取要合并的提交</p> <ol><li><p>执行了rebase命令之后，会弹出一个窗口，头几行如下：</p> <div class="language- extra-class"><pre class="language-text"><code>pick 3ca6ec3   '注释**********'

pick 1b40566   '注释*********'

pick 53f244a   '注释**********'
</code></pre></div></li> <li><p>将pick改为squash或者s,之后保存并关闭文本编辑窗口即可。改完之后文本内容如下：</p> <div class="language- extra-class"><pre class="language-text"><code>pick 3ca6ec3   '注释**********'

s 1b40566   '注释*********'

s 53f244a   '注释**********'
</code></pre></div></li> <li><p>然后保存退出，Git会压缩提交历史，如果有冲突，需要修改，修改的时候要注意，保留最新的历史，不然我们的修改就丢弃了。修改以后要记得敲下面的命令：</p> <div class="language- extra-class"><pre class="language-text"><code>git add .  

git rebase --continue  
</code></pre></div><ul><li>如果你想放弃这次压缩的话，执行以下命令：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>git rebase --abort  
</code></pre></div></li></ol></li> <li><p>解决冲突</p></li> <li><p>输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了</p></li></ol> <h3 id="git-merge和git-rebase区别"><a href="#git-merge和git-rebase区别" class="header-anchor">#</a> git merge和git rebase区别</h3> <h4 id="git-merge"><a href="#git-merge" class="header-anchor">#</a> git merge</h4> <ul><li>会产生一个新的commit，如果合并时遇到冲突，仅需要修改后重新commit</li> <li>优点：记录了真实的commit情况，包括每个分支的详情</li> <li>缺点：每次merge会自动产生一个merge commit,commit比较频繁时，看到分支很杂乱</li></ul> <h4 id="git-rebase"><a href="#git-rebase" class="header-anchor">#</a> git rebase</h4> <ul><li>本质是<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener noreferrer">变基<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>会合并之前的commit历史</li> <li>优点：得到更简洁的项目历史，去掉了merge commit</li> <li>缺点：如果合并出现代码问题不容易定位，因为re-write了history</li> <li>合并时如果出现冲突需要按照如下步骤解决
<ul><li>修改冲突部分</li> <li>git add</li> <li>git rebase --continue</li> <li>（如果第三步无效可以执行  git rebase --skip）</li></ul></li></ul> <h2 id="小程序"><a href="#小程序" class="header-anchor">#</a> 小程序</h2> <h3 id="微信小程序代码量限制问题"><a href="#微信小程序代码量限制问题" class="header-anchor">#</a> 微信小程序代码量限制问题</h3> <ul><li>单个包代码量不大于2M</li> <li>所有分包大小不超过8M</li> <li>分包加载:通过在app.json subPackages 字段声明项目分包结构</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
    'pages': [
          'pages/welcome',
          'pages/movie',
           'pages/tvPlay'
           // 'pages/detail'
    ],
    'subPackages': [
      {
         'root': 'packageA',
            'pages': [
              'pages/detail'
        ]
      }
    ]
}

</code></pre></div><h2 id="vue"><a href="#vue" class="header-anchor">#</a> VUE</h2> <h3 id="vue中的diff算法"><a href="#vue中的diff算法" class="header-anchor">#</a> vue中的diff算法</h3> <h4 id="原理-patchvnode是diff发生的地方-整体策略-深度优先-同层比较"><a href="#原理-patchvnode是diff发生的地方-整体策略-深度优先-同层比较" class="header-anchor">#</a> 原理： （patchVnode是diff发生的地方，整体策略：深度优先，同层比较）</h4> <ul><li>1.先同级比较，在比较子节点</li> <li>2.先判断一方有儿子一方没儿子的情况</li> <li>3.比较都有儿子的情况</li> <li>4.递归比较子节点</li></ul> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结：</h4> <ul><li><p>1.diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM作对比（即diff），将变化的地方更新在真实DOM上；另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)。</p></li> <li><p>2.vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方。</p></li> <li><p>3.vue中diff执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。</p></li> <li><p>4.diff过程整体遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/study-mu/assets/js/app.e89da039.js" defer></script><script src="/study-mu/assets/js/2.3e793b54.js" defer></script><script src="/study-mu/assets/js/35.c2301487.js" defer></script>
  </body>
</html>
