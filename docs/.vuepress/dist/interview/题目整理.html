<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>css | 阿木木的前端笔记</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/study-mu/logo.png">
    <meta name="description" content="阿木木的前端指南">
    <link rel="preload" href="/study-mu/assets/css/0.styles.cefe3876.css" as="style"><link rel="preload" href="/study-mu/assets/js/app.e8ce0402.js" as="script"><link rel="preload" href="/study-mu/assets/js/2.3e793b54.js" as="script"><link rel="preload" href="/study-mu/assets/js/41.fdba4e24.js" as="script"><link rel="prefetch" href="/study-mu/assets/js/10.654992a0.js"><link rel="prefetch" href="/study-mu/assets/js/11.d4068852.js"><link rel="prefetch" href="/study-mu/assets/js/12.b417c42b.js"><link rel="prefetch" href="/study-mu/assets/js/13.d6741064.js"><link rel="prefetch" href="/study-mu/assets/js/14.99c7ce51.js"><link rel="prefetch" href="/study-mu/assets/js/15.fa3a71c7.js"><link rel="prefetch" href="/study-mu/assets/js/16.668c3d22.js"><link rel="prefetch" href="/study-mu/assets/js/17.ff1e343c.js"><link rel="prefetch" href="/study-mu/assets/js/18.ce6b7467.js"><link rel="prefetch" href="/study-mu/assets/js/19.f6737cc6.js"><link rel="prefetch" href="/study-mu/assets/js/20.61b14e2f.js"><link rel="prefetch" href="/study-mu/assets/js/21.885a7018.js"><link rel="prefetch" href="/study-mu/assets/js/22.7d223a1d.js"><link rel="prefetch" href="/study-mu/assets/js/23.dda016cc.js"><link rel="prefetch" href="/study-mu/assets/js/24.2344829f.js"><link rel="prefetch" href="/study-mu/assets/js/25.50e10b30.js"><link rel="prefetch" href="/study-mu/assets/js/26.2262e1d4.js"><link rel="prefetch" href="/study-mu/assets/js/27.03d55779.js"><link rel="prefetch" href="/study-mu/assets/js/28.a488ed82.js"><link rel="prefetch" href="/study-mu/assets/js/29.402707c2.js"><link rel="prefetch" href="/study-mu/assets/js/3.d5750486.js"><link rel="prefetch" href="/study-mu/assets/js/30.f0b63704.js"><link rel="prefetch" href="/study-mu/assets/js/31.427555a0.js"><link rel="prefetch" href="/study-mu/assets/js/32.8c3ca022.js"><link rel="prefetch" href="/study-mu/assets/js/33.9c935557.js"><link rel="prefetch" href="/study-mu/assets/js/34.a6e177bd.js"><link rel="prefetch" href="/study-mu/assets/js/35.d256c2d1.js"><link rel="prefetch" href="/study-mu/assets/js/36.32318275.js"><link rel="prefetch" href="/study-mu/assets/js/37.85f18c6e.js"><link rel="prefetch" href="/study-mu/assets/js/38.3cda4eb6.js"><link rel="prefetch" href="/study-mu/assets/js/39.c54e7025.js"><link rel="prefetch" href="/study-mu/assets/js/4.5ed19beb.js"><link rel="prefetch" href="/study-mu/assets/js/40.13d91d05.js"><link rel="prefetch" href="/study-mu/assets/js/42.13f40481.js"><link rel="prefetch" href="/study-mu/assets/js/43.68b4b728.js"><link rel="prefetch" href="/study-mu/assets/js/44.bd7cd4d4.js"><link rel="prefetch" href="/study-mu/assets/js/45.d358c09a.js"><link rel="prefetch" href="/study-mu/assets/js/46.df689918.js"><link rel="prefetch" href="/study-mu/assets/js/47.6bf2369f.js"><link rel="prefetch" href="/study-mu/assets/js/48.479f2bd2.js"><link rel="prefetch" href="/study-mu/assets/js/49.9be15cde.js"><link rel="prefetch" href="/study-mu/assets/js/5.490b5f30.js"><link rel="prefetch" href="/study-mu/assets/js/50.5a99ea14.js"><link rel="prefetch" href="/study-mu/assets/js/51.637d36ba.js"><link rel="prefetch" href="/study-mu/assets/js/52.fb07877f.js"><link rel="prefetch" href="/study-mu/assets/js/53.3db46c13.js"><link rel="prefetch" href="/study-mu/assets/js/54.55255f35.js"><link rel="prefetch" href="/study-mu/assets/js/55.b02bd47d.js"><link rel="prefetch" href="/study-mu/assets/js/56.fb6677b6.js"><link rel="prefetch" href="/study-mu/assets/js/57.712372ed.js"><link rel="prefetch" href="/study-mu/assets/js/58.fdd35475.js"><link rel="prefetch" href="/study-mu/assets/js/6.65c0cf4b.js"><link rel="prefetch" href="/study-mu/assets/js/7.d25043f9.js"><link rel="prefetch" href="/study-mu/assets/js/8.aaa997ec.js"><link rel="prefetch" href="/study-mu/assets/js/9.7ee563fb.js">
    <link rel="stylesheet" href="/study-mu/assets/css/0.styles.cefe3876.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/study-mu/" class="home-link router-link-active"><img src="/study-mu/logo.png" alt="阿木木的前端笔记" class="logo"> <span class="site-name can-hide">阿木木的前端笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/study-mu/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/web/html/" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/web/css/" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/javaScript/js/" class="nav-link">
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/javaScript/es6/" class="nav-link">
  es6
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/frame/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/frame/react/" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="/study-mu/TypeScript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/study-mu/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/study-mu/http/" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/study-mu/arithmetic/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/study-mu/engineering/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/study-mu/interview/" class="nav-link router-link-active">
  面试问题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识库" class="dropdown-title"><span class="title">知识库</span> <span class="arrow down"></span></button> <button type="button" aria-label="知识库" class="mobile-dropdown-title"><span class="title">知识库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/knowledge/" class="nav-link">
  前端相关知识
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/readingNotes/" class="nav-link">
  读书笔记
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/study-mu/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/web/html/" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/web/css/" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/javaScript/js/" class="nav-link">
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/javaScript/es6/" class="nav-link">
  es6
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/frame/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/frame/react/" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="/study-mu/TypeScript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/study-mu/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/study-mu/http/" class="nav-link">
  http
</a></div><div class="nav-item"><a href="/study-mu/arithmetic/" class="nav-link">
  数据结构与算法
</a></div><div class="nav-item"><a href="/study-mu/engineering/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/study-mu/interview/" class="nav-link router-link-active">
  面试问题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识库" class="dropdown-title"><span class="title">知识库</span> <span class="arrow down"></span></button> <button type="button" aria-label="知识库" class="mobile-dropdown-title"><span class="title">知识库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study-mu/knowledge/" class="nav-link">
  前端相关知识
</a></li><li class="dropdown-item"><!----> <a href="/study-mu/readingNotes/" class="nav-link">
  读书笔记
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/study-mu/interview/" aria-current="page" class="sidebar-link">前端面试问题</a></li><li><a href="/study-mu/interview/html.html" class="sidebar-link">Html 面试题</a></li><li><a href="/study-mu/interview/css.html" class="sidebar-link">Css 面试题</a></li><li><a href="/study-mu/interview/js.html" class="sidebar-link">js基础面试题</a></li><li><a href="/study-mu/interview/jsHigh.html" class="sidebar-link">JS高频面试题</a></li><li><a href="/study-mu/interview/es6.html" class="sidebar-link">es6基础面试题</a></li><li><a href="/study-mu/interview/TypeScript.html" class="sidebar-link">typescript</a></li><li><a href="/study-mu/interview/vue.html" class="sidebar-link">VUE</a></li><li><a href="/study-mu/interview/react.html" class="sidebar-link">React</a></li><li><a href="/study-mu/interview/node.html" class="sidebar-link">Node</a></li><li><a href="/study-mu/interview/arithmetic.html" class="sidebar-link">算法</a></li><li><a href="/study-mu/interview/performance.html" class="sidebar-link">模块化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="css"><a href="#css" class="header-anchor">#</a> css</h1> <h3 id="使用css-让一个div消失在视野中-发挥想象力"><a href="#使用css-让一个div消失在视野中-发挥想象力" class="header-anchor">#</a> 使用css，让一个div消失在视野中，发挥想象力？</h3> <h3 id="请说明z-index的工作原理-适用范围"><a href="#请说明z-index的工作原理-适用范围" class="header-anchor">#</a> 请说明z-index的工作原理，适用范围？</h3> <h4 id="文档流"><a href="#文档流" class="header-anchor">#</a> 文档流</h4> <h4 id="定位"><a href="#定位" class="header-anchor">#</a> 定位</h4> <h3 id="border1px问题的形成原因"><a href="#border1px问题的形成原因" class="header-anchor">#</a> border1px问题的形成原因</h3> <h4 id="产生原因"><a href="#产生原因" class="header-anchor">#</a> 产生原因</h4> <ul><li>设备像素比：dpr=window.devicePixelRatio，也就是设备的物理像素与逻辑像素的比值。像素比 = 物理像素 / css像素</li> <li>在<code>retina</code>屏的手机上, <code>dpr</code>为<code>2</code>或<code>3</code>，<code>css</code>里写的<code>1px</code>宽度映射到物理像素上就有<code>2px</code>或<code>3px</code>宽度。</li> <li>例如：<code>iPhone6</code>的<code>dpr</code>为<code>2</code>，物理像素是<code>750</code>（x轴）,它的逻辑像素为<code>375</code>。也就是说，1个逻辑像素，在<code>x</code>轴和<code>y</code>轴方向，需要2个物理像素来显示，即：dpr=2时，表示1个CSS像素由4个物理像素点组成。</li></ul> <h4 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h4> <h5 id="_0-5px方案"><a href="#_0-5px方案" class="header-anchor">#</a> 0.5px方案</h5> <ul><li><p>在<code>IOS8+</code>，苹果系列都已经支持<code>0.5px</code>了，可以借助媒体查询来处理。</p> <div class="language- extra-class"><pre class="language-text"><code>/*这是css方式*/
.border { border: 1px solid #999 }
@media screen and (-webkit-min-device-pixel-ratio: 2) {
    .border { border: 0.5px solid #999 }
}
/*ios dpr=2和dpr=3情况下border相差无几，下面代码可以省略*/
@media screen and (-webkit-min-device-pixel-ratio: 3) {
    .border { border: 0.333333px solid #999 }
}
</code></pre></div></li> <li><p><code>IOS7</code>及以下和<code>Android</code>等其他系统里，<code>0.5px</code>将会被显示为<code>0px</code>。那么我们就需要想出办法解决，说实在一点就是找到<code>Hack</code>。</p></li> <li><p>解决方案是通过<code>JavaScript</code>检测浏览器能否处理<code>0.5px</code>的边框，如果可以，给<code>html</code>标签元素添加个<code>class</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>if (window.devicePixelRatio &amp;&amp; devicePixelRatio &gt;= 2) {
  var testElem = document.createElement('div');
  testElem.style.border = '.5px solid transparent';
  document.body.appendChild(testElem);
}
if (testElem.offsetHeight == 1) {
  document.querySelector('html').classList.add('hairlines');
}
  document.body.removeChild(testElem);
}
// 脚本应该放在body内，如果在里面运行，需要包装 $(document).ready(function() {})
</code></pre></div></li> <li><p>然后，极细的边框样式就容易了</p> <div class="language- extra-class"><pre class="language-text"><code>div {
  border: 1px solid #bbb;
}
.hairlines div {
  border-width: 0.5px;  
}
</code></pre></div></li> <li><p>优点：简单，不需要过多代码。</p></li> <li><p>缺点：无法兼容安卓设备、 <code>iOS 7</code>及以下设备。</p></li></ul> <h5 id="伪类-transform"><a href="#伪类-transform" class="header-anchor">#</a> 伪类+transform</h5> <ul><li>原理：把原先元素的<code>border</code>去掉，然后利用<code>:before</code>或者<code>:after</code>重做<code>border</code>，并 <code>transform</code>的<code>scale</code>缩小一半，原先的元素相对定位，新做的<code>border</code>绝对定位。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>/*手机端实现真正的一像素边框*/
.border-1px, .border-bottom-1px, .border-top-1px, .border-left-1px, .border-right-1px {
    position: relative;
}

/*线条颜色 黑色*/
.border-1px::after, .border-bottom-1px::after, .border-top-1px::after, .border-left-1px::after, .border-right-1px::after {
    background-color: #000;
}

/*底边边框一像素*/
.border-bottom-1px::after {
    content: &quot;&quot;;
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    transform-origin: 0 0;
}

/*上边边框一像素*/
.border-top-1px::after {
    content: &quot;&quot;;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 1px;
    transform-origin: 0 0;
}

/*左边边框一像素*/
.border-left-1px::after {
    content: &quot;&quot;;
    position: absolute;
    left: 0;
    top: 0;
    width: 1px;
    height: 100%;
    transform-origin: 0 0;
}

/*右边边框1像素*/
.border-right-1px::after {
    content: &quot;&quot;;
    box-sizing: border-box;
    position: absolute;
    right: 0;
    top: 0;
    width: 1px;
    height: 100%;
    transform-origin: 0 0;
}

/*边框一像素*/
.border-1px::after {
    content: &quot;&quot;;
    box-sizing: border-box;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    border: 1px solid gray;
}


/*设备像素比*/
/*显示屏最小dpr为2*/
@media (-webkit-min-device-pixel-ratio: 2) {
    .border-bottom-1px::after, .border-top-1px::after {
        transform: scaleY(0.5);
    }

    .border-left-1px::after, .border-right-1px::after {
        transform: scaleX(0.5);
    }

    .border-1px::after {
        width: 200%;
        height: 200%;
        transform: scale(0.5);
        transform-origin: 0 0;
    }
}

/*设备像素比*/
@media (-webkit-min-device-pixel-ratio: 3)  {
    .border-bottom-1px::after, .border-top-1px::after {
        transform: scaleY(0.333);
    }

    .border-left-1px::after, .border-right-1px::after {
        transform: scaleX(0.333);
    }

    .border-1px::after {
        width: 300%;
        height: 300%;
        transform: scale(0.333);
        transform-origin: 0 0;
    }
}
/*需要注意&lt;input type=&quot;button&quot;&gt;是没有:before, :after伪元素的*/
</code></pre></div><ul><li>优点：所有场景都能满足，支持圆角(伪类和本体类都需要加border-radius)。</li> <li>缺点：代码量也很大，对于已经使用伪类的元素(例如clearfix)，可能需要多层嵌套。</li></ul> <h5 id="viewport-rem"><a href="#viewport-rem" class="header-anchor">#</a> viewport + rem</h5> <ul><li><p>同时通过设置对应<code>viewport</code>的<code>rem</code>基准值，这种方式就可以像以前一样轻松愉快的写1px了。</p></li> <li><p>在<code>devicePixelRatio=2</code> 时，设置<code>meta</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;&gt;
</code></pre></div></li> <li><p>在<code>devicePixelRatio=3</code> 时，设置<code>meta</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&quot;&gt;
</code></pre></div></li> <li><p>验证</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;title&gt;移动端1px问题&lt;/title&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; id=&quot;WebViewport&quot;
        content=&quot;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt;
    &lt;style&gt;
        html {
            font-size: 11px;
        }
        body {
            padding: 1rem;
        }
        * {
            padding: 0;
            margin: 0;
        }
        .item {
            padding: 1rem;
            border-bottom: 1px solid gray;
            font-size: 1.2rem;
        }
    &lt;/style&gt;
    &lt;script&gt;
        var viewport = document.querySelector(&quot;meta[name=viewport]&quot;);
        var dpr = window.devicePixelRatio || 1;
        var scale = 1 / dpr;
        //下面是根据设备dpr设置viewport
        viewport.setAttribute(
            &quot;content&quot;, +
            &quot;width=device-width,&quot; +
            &quot;initial-scale=&quot; +
            scale +
            &quot;, maximum-scale=&quot; +
            scale +
            &quot;, minimum-scale=&quot; +
            scale +
            &quot;, user-scalable=no&quot;
        );

        var docEl = document.documentElement;
        var fontsize = 10 * (docEl.clientWidth / 320) + &quot;px&quot;;
        docEl.style.fontSize = fontsize;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;item&quot;&gt;border-bottom: 1px solid gray;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;border-bottom: 1px solid gray;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></li> <li><p>优点：所有场景都能满足，一套代码，可以兼容基本所有布局。</p></li> <li><p>缺点：老项目修改代价过大，只适用于新项目。</p></li></ul> <h5 id="border-image"><a href="#border-image" class="header-anchor">#</a> border-image</h5> <h5 id="background-image"><a href="#background-image" class="header-anchor">#</a> background-image</h5> <div class="language- extra-class"><pre class="language-text"><code>.background-image-1px {
  background: url(../img/line.png) repeat-x left bottom;
  background-size: 100% 1px;
}
</code></pre></div><ul><li>优点：可以设置单条,多条边框，没有性能瓶颈的问题。</li> <li>缺点：修改颜色麻烦, 需要替换图片；圆角需要特殊处理，并且边缘会模糊。</li></ul> <h5 id="postcss-write-svg"><a href="#postcss-write-svg" class="header-anchor">#</a> postcss-write-svg</h5> <ul><li><p>使用<code>border-image</code>每次都要去调整图片，总是需要成本的。基于上述的原因，我们可以借助于<code>PostCSS</code>的插件<code>postcss-write-svg</code>来帮助我们。如果你的项目中已经有使用<code>PostCSS</code>，那么只需要在项目中安装这个插件。然后在你的代码中使用：</p> <div class="language- extra-class"><pre class="language-text"><code>@svg 1px-border {
    height: 2px;
    @rect {
      fill: var(--color, black);
      width: 100%;
      height: 50%;
    }
}
.example {
    border: 1px solid transparent;
    border-image: svg(1px-border param(--color #00b1ff)) 2 2 stretch;
 }
 // 编辑出来
 .example {
    border: 1px solid transparent;
    border-image: url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E&quot;)
          2 2 stretch;
  }
</code></pre></div></li></ul> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <ul><li><code>0.5px</code>，相信浏览器肯定是会慢慢支持的，目前而言，如果能用的话，可以<code>hack</code>一下。</li> <li>对于老项目，建议采用<code>transform</code>+伪类。</li> <li>新项目可以设置<code>viewport</code>的<code>scale</code>值，这个方法兼容性好。</li> <li><code>postcss-write-svg</code>简单易用，仅适合直线，圆角建议用<code>transform</code>+伪类实现。</li></ul> <h3 id="谈谈你对html5的理解"><a href="#谈谈你对html5的理解" class="header-anchor">#</a> 谈谈你对HTML5的理解？</h3> <h3 id="如何使用一个div里面的文字垂直居中-且该文字的大小根据屏幕大小自适应"><a href="#如何使用一个div里面的文字垂直居中-且该文字的大小根据屏幕大小自适应" class="header-anchor">#</a> 如何使用一个div里面的文字垂直居中，且该文字的大小根据屏幕大小自适应？</h3> <h3 id="考察盒子模型和-box-sizing-属性-判断元素的尺寸和颜色。"><a href="#考察盒子模型和-box-sizing-属性-判断元素的尺寸和颜色。" class="header-anchor">#</a> 考察盒子模型和 <code>box-sizing</code> 属性，判断元素的尺寸和颜色。</h3> <h3 id="垂直水平居中"><a href="#垂直水平居中" class="header-anchor">#</a> 垂直水平居中</h3> <ol><li>position有哪些属性</li> <li>less,sass它们的作用是什么</li></ol> <h3 id="css-优先级"><a href="#css-优先级" class="header-anchor">#</a> css 优先级</h3> <ul><li>important &gt; 内联 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器</li></ul> <h3 id="避免-css-全局污染。"><a href="#避免-css-全局污染。" class="header-anchor">#</a> 避免 css 全局污染。</h3> <ul><li>我常用的 css modules</li> <li>scoped</li></ul> <h4 id="css-modules-的原理"><a href="#css-modules-的原理" class="header-anchor">#</a> css modules 的原理</h4> <ul><li>生成唯一的类名</li></ul> <h3 id="有一个-a-标签-如何动态的决定他的样式。"><a href="#有一个-a-标签-如何动态的决定他的样式。" class="header-anchor">#</a> 有一个 a 标签，如何动态的决定他的样式。</h3> <ul><li>我说了先写几个 css，然后外部传一个前缀的方式。面试官问了都要这样吗？我说可以通过 context 的方式，就不需要每个组件都传了。</li></ul> <h3 id="用css画一个扇形"><a href="#用css画一个扇形" class="header-anchor">#</a> 用css画一个扇形</h3> <h2 id="flex"><a href="#flex" class="header-anchor">#</a> flex</h2> <h3 id="flex-0-1-auto-是什么意思"><a href="#flex-0-1-auto-是什么意思" class="header-anchor">#</a> <code>flex: 0 1 auto;</code> 是什么意思？</h3> <ul><li>flex 这个属性常考题，好好把阮老师的那篇 <strong>flex 语法篇</strong>[2]看完 flex 的面试题基本没问题。</li> <li>flex 语法篇: <em>https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</em></li></ul> <h2 id="less"><a href="#less" class="header-anchor">#</a> less</h2> <h3 id="less-的-代表什么"><a href="#less-的-代表什么" class="header-anchor">#</a> less 的&amp;代表什么</h3> <h2 id="动画"><a href="#动画" class="header-anchor">#</a> 动画</h2> <h3 id="动画-补间动画实现"><a href="#动画-补间动画实现" class="header-anchor">#</a> 动画？补间动画实现</h3> <ul><li>补间动画就是指控制最开始的状态和最末的状态的动画，中间的状态由浏览器自动帮我们计算生成</li> <li>transition动画最主要的属性是transition属性，它其实是4个属性的缩写。</li></ul> <h1 id="html"><a href="#html" class="header-anchor">#</a> HTML</h1> <h2 id="设计一个-input-组件需要哪些属性"><a href="#设计一个-input-组件需要哪些属性" class="header-anchor">#</a> 设计一个 input 组件需要哪些属性</h2> <ul><li>value 、defaultValue、onChange</li> <li>value 的类型是什么？</li> <li>onChange 怎么规定 value 的类型</li></ul> <h1 id="js基础"><a href="#js基础" class="header-anchor">#</a> js基础</h1> <h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h2> <h3 id="js判断数组的5种方式"><a href="#js判断数组的5种方式" class="header-anchor">#</a> JS判断数组的5种方式</h3> <ul><li>instanceof</li></ul> <div class="language- extra-class"><pre class="language-text"><code> arr isntanceof Array
</code></pre></div><ul><li><p><strong>proto</strong></p> <div class="language- extra-class"><pre class="language-text"><code> arr.__proto__  === Array.prototype
</code></pre></div></li> <li><p>constructor</p> <div class="language- extra-class"><pre class="language-text"><code>arr.constructor === Array
</code></pre></div></li> <li><p>Object.prototype.toString</p> <div class="language- extra-class"><pre class="language-text"><code>// 过object类型的副属性class去判断的，其中函数的class是Function，结果是[object Function]， 普通的对象是Object，结果是[object Object]
Object.prototype.toString.call(arr) === '[object Array]'
</code></pre></div></li> <li><p>Array.isArray</p> <div class="language- extra-class"><pre class="language-text"><code>// es6新增的方法
Array.isArray(arr)
</code></pre></div></li></ul> <h3 id="手写instanceof及原理"><a href="#手写instanceof及原理" class="header-anchor">#</a> 手写instanceof及原理</h3> <ul><li><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链</p></li> <li><p>instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</p> <div class="language- extra-class"><pre class="language-text"><code>const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str1 = 'hello world'
str1 instanceof String // false

var str2 = new String('hello world')
str2 instanceof String // true

// 判断基本数据类型
// 其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。
class PrimitiveNumber {
  static [Symbol.hasInstance](x) {
    return typeof x === 'number'
  }
}
console.log(111 instanceof PrimitiveNumber) // true
</code></pre></div></li></ul> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <h3 id="怎么理解闭包"><a href="#怎么理解闭包" class="header-anchor">#</a> 怎么理解闭包</h3> <ul><li>基础中的基础，虽然社招考得不多，但是如果连闭包都理解不了，应该会减分不少。闭包由于在规范里没有定义，所以很多人下的定义不一样，理解的角度也不同，但是自己要有一套正确的理解方式，如果按照我的理解 JavaScript 里面所有的函数都是闭包，因为有全局环境，所有的函数都可以访问全局变量。</li></ul> <h3 id="节流和防抖的实现"><a href="#节流和防抖的实现" class="header-anchor">#</a> 节流和防抖的实现</h3> <ul><li>防抖和节流的代码还是需要会手写的，这也是一个闭包的例子，</li></ul> <h2 id="异步"><a href="#异步" class="header-anchor">#</a> 异步</h2> <h3 id="用settimeout实现setinterval"><a href="#用settimeout实现setinterval" class="header-anchor">#</a> 用setTimeout实现setInterval</h3> <div class="language- extra-class"><pre class="language-text"><code>function mySetInterval(fn, millisec,count){
  function interval(){
    if(typeof count===‘undefined’||count--&gt;0){
      setTimeout(interval, millisec);
      try{
        fn()
      }catch(e){
        count = 0;
        throw e.toString();
      }
    }
  }
  setTimeout(interval, millisec)
}
</code></pre></div><ul><li><p>这个<code>mySetInterval</code>函数有一个叫做<code>interval</code>的内部函数，它通过<code>setTimeout</code>来自动被调用，在<code>interval</code>中有一个闭包，调用了回调函数并通过<code>setTimeout</code>再次调用了<code>interval</code>。</p></li> <li><p>增加一个额外的参数用来标明代码执行的次数</p></li></ul> <h3 id="实现原生ajax"><a href="#实现原生ajax" class="header-anchor">#</a> 实现原生ajax</h3> <h2 id="原生js问题"><a href="#原生js问题" class="header-anchor">#</a> 原生js问题</h2> <h3 id="for-in-和-for-of的区别详解以及为for-in的输出顺序"><a href="#for-in-和-for-of的区别详解以及为for-in的输出顺序" class="header-anchor">#</a> for in 和 for of的区别详解以及为for in的输出顺序</h3> <ul><li><p>都是用来遍历属性</p> <div class="language- extra-class"><pre class="language-text"><code>// 例1 遍历对象
const obj = {
        a: 1,
        b: 2,
        c: 3
    }
for (let i in obj) {
    console.log(i)
    // a
    // b
    // c
}
for (let i of obj) {
    console.log(i)
    // Uncaught TypeError: obj is not iterable 报错了
}
// 例2 遍历数组
const arr = ['a', 'b', 'c']
    // for in 循环
for (let i in arr) {
    console.log(i)
    // 0
    // 1
    // 2
}

// for of
for (let i of arr) {
    console.log(i)
    // a
    // b
    // c
}
// 例3
const arr = ['a', 'b']
// 手动给 arr数组添加一个属性
arr.name = 'qiqingfu'

// for in 循环可以遍历出 name 这个键名
for (let i in arr) {
    console.log(i)
    // a
    // b
    // name
}
</code></pre></div></li> <li><p>for in的特点</p> <ul><li>for ... in 循环返回的值都是数据结构的 键值名。</li> <li>遍历对象返回的对象的key值,遍历数组返回的数组的下标(key)。</li> <li>for ... in 循环不仅可以遍历数字键名,还会遍历原型上的值和手动添加的其他键。如——例3</li> <li>特别情况下, for ... in 循环会以看起来任意的顺序遍历键名</li> <li><strong>总结一句: for in 循环特别适合遍历对象。</strong></li></ul></li> <li><p>for of的特点</p> <ul><li>for of 循环用来获取一对键值对中的值,而 for in 获取的是 键名</li> <li>一个数据结构只要部署了 <strong>Symbol.iterator</strong> 属性, 就被视为具有 iterator接口, 就可以使用 for of循环。</li> <li>例1这个对象,没有 Symbol.iterator这个属性,所以使用 for of会报 obj is not iterable</li> <li>for of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。</li> <li>提供了遍历所有数据结构的统一接口</li></ul></li> <li><p>部署了Symbol。iterator属性的数据结构</p> <ul><li>只要有 iterator 接口的数据结构,都可以使用 for of循环。
<ul><li>数组 Array</li> <li>Map</li> <li>Set</li> <li>String</li> <li>arguments对象</li> <li>Nodelist对象, 就是获取的dom列表集合</li></ul></li></ul></li> <li><p>以上这些都可以直接使用 for of 循环。凡是部署了 iterator 接口的数据结构也都可以使用数组的 扩展运算符(...)、和解构赋值等操作。</p></li> <li><p>让对象可以使用for of循环</p> <ul><li><p>使用 Object.keys() 获取对象的 key值集合后,再使用 for of</p> <div class="language- extra-class"><pre class="language-text"><code> const obj = {
        a: 1,
        b: 2,
        c: 3
    }

    for (let i of Object.keys(obj)) {
        console.log(i)
        // 1
        // 2
        // 3
    }
</code></pre></div></li></ul></li></ul> <h1 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h1> <h3 id="let-var-const-有什么区别"><a href="#let-var-const-有什么区别" class="header-anchor">#</a> let var const 有什么区别</h3> <h3 id="原型-class-b-继承-class-a-翻译成-es5-应该是什么样子"><a href="#原型-class-b-继承-class-a-翻译成-es5-应该是什么样子" class="header-anchor">#</a> 原型，class B 继承 class A 翻译成 es5 应该是什么样子</h3> <ul><li>说实话，我觉得这道题其实蛮有水平的，即考察了如何写出一个好的继承方式，也对 new 过程进行了考察，还对考察了对 Class 的理解。</li> <li>注意的点：<code>class</code> 是有重载功能的，怎么在子类的构造函数里面调用 <code>super</code></li></ul> <h2 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h2> <h3 id="手写promise"><a href="#手写promise" class="header-anchor">#</a> 手写Promise</h3> <h3 id="手写promise-all"><a href="#手写promise-all" class="header-anchor">#</a> 手写Promise.all</h3> <h3 id="写一个-promise-重试函数-可以设置时间间隔和次数。function-foo-fn-interval-times"><a href="#写一个-promise-重试函数-可以设置时间间隔和次数。function-foo-fn-interval-times" class="header-anchor">#</a> 写一个 promise 重试函数，可以设置时间间隔和次数。<code>function foo(fn, interval, times) {}</code></h3> <h1 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h1> <ol><li>cookie有哪些属性</li> <li>cookie,session,localstorage,sessionstorage有什么区别</li> <li>怎么禁止js访问cookie</li></ol> <h1 id="网络"><a href="#网络" class="header-anchor">#</a> 网络</h1> <ol><li>简述https原理，以及与http的区别</li> <li>操作系统中进程和线程怎么通信</li> <li>你知道哪些http头部</li> <li>怎么与服务端保持连接</li> <li>http请求跨域问题，你都知道哪些解决跨域的方法</li> <li>你了解哪些请求方法，分别有哪些作用和不同</li> <li>浏览器缓存</li> <li>jsonp实现一下跨域</li> <li>你知道哪些状态码</li> <li>options请求方法有什么用</li></ol> <h2 id="浏览器缓存"><a href="#浏览器缓存" class="header-anchor">#</a> 浏览器缓存</h2> <ul><li>浏览器缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。</li> <li>控制强缓存的字段有：Expires 和 Cache-Control，Expires 和 Cache-Control。</li> <li>控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。</li></ul> <h1 id="vue"><a href="#vue" class="header-anchor">#</a> VUE</h1> <ol><li>vue-router源码</li> <li>vue原理（手写代码，实现数据劫持）</li> <li>Object.defineProperty除了set get外还有什么属性，我回答了configurable enumerable</li></ol> <h2 id="有用-ssr"><a href="#有用-ssr" class="header-anchor">#</a> 有用 ssr</h2> <h1 id="react"><a href="#react" class="header-anchor">#</a> React</h1> <ul><li><a href="https://react.iamkasong.com/#%E7%AB%A0%E8%8A%82%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener noreferrer">https://react.iamkasong.com/#%E7%AB%A0%E8%8A%82%E8%AF%B4%E6%98%8E<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="react-的基本原理"><a href="#react-的基本原理" class="header-anchor">#</a> react 的基本原理</h2> <ul><li>UI = f(state) ，虚拟 DOM、diff 策略、setState</li></ul> <h2 id="rreact事件机制"><a href="#rreact事件机制" class="header-anchor">#</a> Rreact事件机制</h2> <ul><li>一文吃透 React 事件机制原理: <em>https://toutiao.io/posts/28of14w/preview</em></li> <li>React 为什么要用合成事件</li> <li>事件机制：注册和分发的过程。这里面至少要说出事件注册都是在元素的最顶层 <code>document</code> 节点上。</li></ul> <h2 id="聊聊-react-的-diff"><a href="#聊聊-react-的-diff" class="header-anchor">#</a> 聊聊 React 的 diff</h2> <p>聊 diff 建议先看看我之前写过的一篇关于虚拟 DOM 的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&amp;mid=2247484879&amp;idx=1&amp;sn=ee0d2e3e235fa911ce2878ae2ea2b676&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">从 React 历史的长河里聊虚拟 DOM 及其价值<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，有助于理解 diff 的意义。</p> <p>diff 的细节可以看我之前写的：<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&amp;mid=2247484536&amp;idx=1&amp;sn=94777b8c1aab80dffe1fc224bec02c72&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">详解 React 16 的 Diff 策略<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="react-优化"><a href="#react-优化" class="header-anchor">#</a> React 优化</h2> <p>可以看之前我写的 <a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&amp;mid=2247484774&amp;idx=1&amp;sn=9dc58e54a28755504d58bef49a78f3b4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">React 函数式组件性能优化指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，对于类组件也有对应的 API。</p> <h2 id="聊一聊-react-的生命周期"><a href="#聊一聊-react-的生命周期" class="header-anchor">#</a> 聊一聊 React 的生命周期</h2> <ul><li>尽量把 React 15 和 16 的进行对比，然后 16 为什么要准备废除那几个生命周期，以及新增的生命周期可以进行替代。</li> <li>这个图好好的理解一下<img src="/Users/mumu/Documents/webExercise/640.jpeg" alt="640"></li></ul> <h3 id="react-16-生命周期有什么改变"><a href="#react-16-生命周期有什么改变" class="header-anchor">#</a> react 16 生命周期有什么改变</h3> <div class="language- extra-class"><pre class="language-text"><code>componentWillMount`，`componentWillReceiveProps`，`componentWillUpdate`准备废除，新增了 `static getDerivedStateFromProps` 和 `getSnapshotBeforeUpdate
</code></pre></div><p>我还详细的介绍了为什么要用 <code>getDerivedStateFromProps</code> 来代替即将废除的三个生命周期，主要是 16 版本 render 之前的生命周期可能会被多次执行，具体的可看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&amp;mid=2247484469&amp;idx=1&amp;sn=f68d044f1b0e4e2eb981e3878427b75b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">Deep In React 之浅谈 React Fiber 架构(一)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="getderivedstatefromprops"><a href="#getderivedstatefromprops" class="header-anchor">#</a> getDerivedStateFromProps</h3> <h2 id="聊一聊-hooks-怎么处理生命周期"><a href="#聊一聊-hooks-怎么处理生命周期" class="header-anchor">#</a> 聊一聊 hooks 怎么处理生命周期</h2> <ul><li>讲道理函数式组件是没有生命周期的，但是如何去模拟类组件的生命周期的作用，都是在 <code>useEffect</code> 里面进行操作的，因为生命周期里面所做的基本都是副作用，放到 <code>useEffect</code> 里是最合适的，专门用来处理副作用。</li></ul> <h2 id="那你聊聊-react-的源码-把你记得起的讲一讲"><a href="#那你聊聊-react-的源码-把你记得起的讲一讲" class="header-anchor">#</a> 那你聊聊 React 的源码，把你记得起的讲一讲</h2> <blockquote><p>我看过 React 的一部分源码的，所以关于 React 源码更新部分的东西，应该基本都能说个大概。</p></blockquote> <ul><li>FiberNode 有哪些属性</li> <li>stadeNode 有什么用？</li></ul> <h2 id="react基础问题"><a href="#react基础问题" class="header-anchor">#</a> react基础问题</h2> <h3 id="react-里有动态加载的-api-吗"><a href="#react-里有动态加载的-api-吗" class="header-anchor">#</a> react 里有动态加载的 api 吗？</h3> <ul><li>React.lazy</li></ul> <h3 id="react-lazy原理"><a href="#react-lazy原理" class="header-anchor">#</a> React.lazy原理</h3> <h2 id="redux-的重点概念"><a href="#redux-的重点概念" class="header-anchor">#</a> redux 的重点概念</h2> <ul><li>store、reduce、action、actionCreater、dispatch</li> <li>状态管理常用的是 redux 和 dva，然后再聊了聊区别已经 redux 的理念</li></ul> <h3 id="实现一个-redux"><a href="#实现一个-redux" class="header-anchor">#</a> 实现一个 redux</h3> <ul><li>实现 <code>createStore</code> 的功能，关键点发布订阅的功能，以及取消订阅的功能。</li></ul> <h2 id="class-组件与函数式组件的区别"><a href="#class-组件与函数式组件的区别" class="header-anchor">#</a> class 组件与函数式组件的区别</h2> <ul><li>生命周期、设计理念，感觉这道题比较开发，可以看看 dan 的这篇：<strong>函数式组件与类组件有何不同？</strong>[3]</li> <li>函数式组件与类组件有何不同？: <em>https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/</em></li></ul> <h1 id="算法"><a href="#算法" class="header-anchor">#</a> 算法</h1> <ol><li>算法：实现36进制转换</li> <li>树的遍历有几种方式，实现下层次遍历</li> <li>判断对称二叉树</li> <li>合并乱序区间</li> <li>算法题：老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。目标是尽量让更多的孩子满意。如孩子的要求是 1, 3, 5, 4, 2，饼干是1, 1，最多能让1个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是7, 6, 5，最多能让2个孩子满足。</li> <li>算法题：给定一个正整数数列a, 对于其每个区间, 我们都可以计算一个X值;X值的定义如下: 对于任意区间, 其X值等于区间内最小的那个数乘上区间内所有数和;现在需要你找出数列a的所有区间中, X值最大的那个区间;如数列a为: 3 1 6 4 5 2; 则X值最大的区间为6, 4, 5, X = 4 * (6+4+5) = 60;</li> <li>算法题：两个有序链表和并成一个有序链表</li></ol> <h3 id="怎么判断单链表相交。"><a href="#怎么判断单链表相交。" class="header-anchor">#</a> 怎么判断单链表相交。</h3> <ul><li>很多种方法，我当时说的是最后一个节点如果相同，那么就代表相交。</li></ul> <h3 id="怎么找到第一个相交的节点"><a href="#怎么找到第一个相交的节点" class="header-anchor">#</a> 怎么找到第一个相交的节点</h3> <ul><li>同时遍历两个链表到尾部，同时记录两个链表的长度。若两个链表最后的一个节点相同，则两个链表相交。有两个链表的长度后，我们就可以知道哪个链表长，设较长的链表长度为 len1,短的链表长度为 len2。则先让较长的链表向后移动(len1-len2)个长度。然后开始从当前位置同时遍历两个链表，当遍历到的链表的节点相同时，则这个节点就是第一个相交的节点。</li> <li>这是我刚想到的一种方式，不过当时面试的时候我记得好像更简单，但是想不起来了。</li></ul> <h3 id="求最大公共前缀"><a href="#求最大公共前缀" class="header-anchor">#</a> 求最大公共前缀</h3> <ul><li>如 <code>['aaafsd', 'aawwewer', 'aaddfff'] =&gt; 'aa'</code></li></ul> <h1 id="模块化"><a href="#模块化" class="header-anchor">#</a> 模块化</h1> <h2 id="import-和-require-导入的区别"><a href="#import-和-require-导入的区别" class="header-anchor">#</a> import 和 require 导入的区别</h2> <ul><li><p>高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。2.前者编译时输出接口，后者运行时加载。</p></li> <li><p>推荐文章：<strong>前端模块化：CommonJS,AMD,CMD,ES6</strong>[4]</p></li> <li><p>前端模块化：CommonJS,AMD,CMD,ES6: <em>https://juejin.im/post/5aaa37c8f265da23945f365c</em></p></li></ul> <h3 id="require-有什么性能问题"><a href="#require-有什么性能问题" class="header-anchor">#</a> require 有什么性能问题</h3> <h2 id="组件库如何做按需加载"><a href="#组件库如何做按需加载" class="header-anchor">#</a> 组件库如何做按需加载</h2> <ul><li>我常用的是<code>babel-plugin-import</code></li> <li></li></ul> <h1 id="工程化"><a href="#工程化" class="header-anchor">#</a> 工程化</h1> <ol><li>webpack怎么优化</li> <li>happypack和treeshaking作用</li> <li>项目优化</li> <li>你做的项目有什么值得说的</li></ol> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> Webpack</h2> <h3 id="webpack-如何实现动态加载"><a href="#webpack-如何实现动态加载" class="header-anchor">#</a> webpack 如何实现动态加载</h3> <ul><li>讲道理 webpack 动态加载就两种方式：<code>import()</code>和 <code>require.ensure</code>，不过他们实现原理是相同的。</li> <li>我觉得这道题的重点在于动态的创建 script 标签，以及通过 <code>jsonp</code> 去请求 <strong>chunk</strong>，推荐的文章是：<strong>webpack 是如何实现动态导入的</strong>[5]</li> <li>webpack 是如何实现动态导入的: <em>https://juejin.im/post/5d26e7d1518825290726f67a</em></li></ul> <h3 id="webpack-能动态加载-require-引入的模块吗"><a href="#webpack-能动态加载-require-引入的模块吗" class="header-anchor">#</a> webpack 能动态加载 require 引入的模块吗？</h3> <ul><li>应该是不能的，前面说了，webpack 支持动态导入基本上只能用<code>import()</code> 和<code>require.ensure</code>。</li></ul> <h3 id="require-引入的模块-webpack-能做-tree-shaking-吗"><a href="#require-引入的模块-webpack-能做-tree-shaking-吗" class="header-anchor">#</a> require 引入的模块 webpack 能做 Tree Shaking 吗？</h3> <ul><li>不能，Tree Shaking 需要静态分析，只有 ES6 的模块才支持。</li></ul> <h1 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h1> <h2 id="简历里面的性能优化是如何做的"><a href="#简历里面的性能优化是如何做的" class="header-anchor">#</a> 简历里面的性能优化是如何做的</h2> <ul><li>减少请求频率、图片压缩、<code>React.memo</code>、<code>React.useMemo</code></li></ul> <h2 id="框架性能优化"><a href="#框架性能优化" class="header-anchor">#</a> 框架性能优化</h2> <h3 id="如何优化spa应用的首屏加载速度慢的问题"><a href="#如何优化spa应用的首屏加载速度慢的问题" class="header-anchor">#</a> 如何优化SPA应用的首屏加载速度慢的问题</h3> <ul><li>将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</li> <li>在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</li> <li>加一个首屏 loading 图，提升用户体验；</li> <li>如果在webview中的页面，可以进行页面预加载</li> <li>独立打包异步组件公共 Bundle，以提高复用性&amp;缓存命中率</li> <li>静态文件本地缓存，有两种方式分别为HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头和Service Worker离线缓存</li> <li>配合 PWA 使用</li> <li>SSR</li> <li>root中插入loading 或者 骨架屏 prerender-spa-plugin</li> <li>去掉外链css</li> <li>http缓存资源 cache-control &gt; expires &gt; etag &gt; last-modified</li> <li>使用动态 polyfill</li> <li>使用 SplitChunksPlugin 自动拆分业务基础库，避免加载重复模块</li> <li>使用 Tree Shaking 减少业务代码体积</li> <li>懒加载：动态import，loaddable</li> <li>把代码编译到 ES2015+</li> <li>使用 lazyload 和 placeholder 提升加载体验</li></ul> <h2 id="class-组件里面如何做性能优化-因为前面我说了用-react-memo-做了性能优化"><a href="#class-组件里面如何做性能优化-因为前面我说了用-react-memo-做了性能优化" class="header-anchor">#</a> class 组件里面如何做性能优化(因为前面我说了用 React.memo 做了性能优化)</h2> <ul><li>shouldComponentUpdate(简称 SCU)。SCU 跟 immutable 强相关，一定要好好理解 react 的 immutable，否则很可能理解不了为什么不能直接去修改 state，然后再去 setState，以及 redux 的 reducer 要返回一个新的对象。</li></ul> <h1 id="node"><a href="#node" class="header-anchor">#</a> Node</h1> <ol><li>node中cluster是怎样开启多进程的，并且一个端口可以被多个进程监听吗</li> <li>你了解node多进程吗</li> <li>node进程中怎么通信</li> <li>node可以开启多线程吗</li></ol> <h1 id="typescript"><a href="#typescript" class="header-anchor">#</a> typescript</h1> <ol><li>你觉得typescript和javascript有什么区别</li> <li>typescript你都用过哪些类型</li> <li>typescript中type和interface的区别</li> <li>Ts 有什么优势- 讲道理所有现在在网上能查到的优势都是得益于<strong>静态语言</strong>的优势。</li></ol> <h3 id="实现一个-typescript-里的-pick"><a href="#实现一个-typescript-里的-pick" class="header-anchor">#</a> 实现一个 Typescript 里的 Pick</h3> <ul><li>type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P] }</li></ul> <h3 id="type-和-interface-的区别"><a href="#type-和-interface-的区别" class="header-anchor">#</a> type 和 interface 的区别</h3> <ul><li>这是一个高频题，如果考察 TS，这应该是最容易考察的，网上也都能查到相关的资料，但是很可能忽略一个点：<strong>type 只是一个类型别名，并不会产生类型</strong>。所以其实 type 和 interface 其实不是同一个概念，其实他们俩不应该用来比较的，只是有时候用起来看着类似。</li></ul> <h3 id="ts-实现一个-redux"><a href="#ts-实现一个-redux" class="header-anchor">#</a> ts 实现一个 redux</h3> <h1 id="笔试题"><a href="#笔试题" class="header-anchor">#</a> 笔试题</h1> <div class="language- extra-class"><pre class="language-text"><code>const a = { b: 3}

function foo(obj) {
  obj.b = 5

  return obj
}

const aa = foo(a)

console.log(a.b)	// 5

console.log(aa.b) // 5
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function Ofo() {}

function Bick() {
	this.name = 'mybick'
}

var myBick = new Ofo()

Ofo.prototype = new Bick()

var youbick = new Bick()

console.log(myBick.name)

console.log(youbick.name)
</code></pre></div><h3 id="实现一个-fill-函数-不能用循环。"><a href="#实现一个-fill-函数-不能用循环。" class="header-anchor">#</a> 实现一个 fill 函数，不能用循环。</h3> <ul><li>考察递归</li></ul> <h3 id="用-es5-实现私有变量"><a href="#用-es5-实现私有变量" class="header-anchor">#</a> 用 ES5 实现私有变量</h3> <ul><li>考察闭包的使用</li></ul> <h3 id="手写-并发只能10个"><a href="#手写-并发只能10个" class="header-anchor">#</a> 手写：并发只能10个</h3> <p><strong>考虑过 Vue.js、React 这类的框架为什么要用 Virtual DOM 机制吗？</strong></p> <p>1、React / Vue.js 之类的框架为什么需要给组件添加 key 属性，其作用是什么？</p> <p>2、如何判断当前代码是运行在浏览器还是 Node.js 环境中？</p> <p>3、Sourcemap 是什么？有什么作用？生产环境中应该怎么用？</p> <p>4、说一下 Webpack 的热更新原理吧</p> <p>5、简要描述一下什么是消息队列，宏任务和微任务分别又是怎么回事</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/study-mu/assets/js/app.e8ce0402.js" defer></script><script src="/study-mu/assets/js/2.3e793b54.js" defer></script><script src="/study-mu/assets/js/41.fdba4e24.js" defer></script>
  </body>
</html>
