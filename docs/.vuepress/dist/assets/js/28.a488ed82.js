(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{381:function(a,t,v){"use strict";v.r(t);var _=v(42),e=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[a._v("#")]),a._v(" 算法")]),a._v(" "),v("ol",[v("li",[a._v("算法：实现36进制转换")]),a._v(" "),v("li",[a._v("树的遍历有几种方式，实现下层次遍历")]),a._v(" "),v("li",[a._v("判断对称二叉树")]),a._v(" "),v("li",[a._v("合并乱序区间")]),a._v(" "),v("li",[a._v("算法题：老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。目标是尽量让更多的孩子满意。如孩子的要求是 1, 3, 5, 4, 2，饼干是1, 1，最多能让1个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是7, 6, 5，最多能让2个孩子满足。")]),a._v(" "),v("li",[a._v("算法题：给定一个正整数数列a, 对于其每个区间, 我们都可以计算一个X值;X值的定义如下: 对于任意区间, 其X值等于区间内最小的那个数乘上区间内所有数和;现在需要你找出数列a的所有区间中, X值最大的那个区间;如数列a为: 3 1 6 4 5 2; 则X值最大的区间为6, 4, 5, X = 4 * (6+4+5) = 60;")]),a._v(" "),v("li",[a._v("算法题：两个有序链表和并成一个有序链表")])]),a._v(" "),v("h3",{attrs:{id:"怎么判断单链表相交。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#怎么判断单链表相交。"}},[a._v("#")]),a._v(" 怎么判断单链表相交。")]),a._v(" "),v("ul",[v("li",[a._v("很多种方法，我当时说的是最后一个节点如果相同，那么就代表相交。")])]),a._v(" "),v("h3",{attrs:{id:"怎么找到第一个相交的节点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#怎么找到第一个相交的节点"}},[a._v("#")]),a._v(" 怎么找到第一个相交的节点")]),a._v(" "),v("ul",[v("li",[a._v("同时遍历两个链表到尾部，同时记录两个链表的长度。若两个链表最后的一个节点相同，则两个链表相交。有两个链表的长度后，我们就可以知道哪个链表长，设较长的链表长度为 len1,短的链表长度为 len2。则先让较长的链表向后移动(len1-len2)个长度。然后开始从当前位置同时遍历两个链表，当遍历到的链表的节点相同时，则这个节点就是第一个相交的节点。")]),a._v(" "),v("li",[a._v("这是我刚想到的一种方式，不过当时面试的时候我记得好像更简单，但是想不起来了。")])]),a._v(" "),v("h3",{attrs:{id:"求最大公共前缀"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#求最大公共前缀"}},[a._v("#")]),a._v(" 求最大公共前缀")]),a._v(" "),v("ul",[v("li",[a._v("如 "),v("code",[a._v("['aaafsd', 'aawwewer', 'aaddfff'] => 'aa'")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);