(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{369:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"css"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[t._v("#")]),t._v(" css")]),t._v(" "),s("h3",{attrs:{id:"使用css-让一个div消失在视野中-发挥想象力"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用css-让一个div消失在视野中-发挥想象力"}},[t._v("#")]),t._v(" 使用css，让一个div消失在视野中，发挥想象力？")]),t._v(" "),s("h3",{attrs:{id:"请说明z-index的工作原理-适用范围"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请说明z-index的工作原理-适用范围"}},[t._v("#")]),t._v(" 请说明z-index的工作原理，适用范围？")]),t._v(" "),s("h4",{attrs:{id:"文档流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文档流"}},[t._v("#")]),t._v(" 文档流")]),t._v(" "),s("h4",{attrs:{id:"定位"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定位"}},[t._v("#")]),t._v(" 定位")]),t._v(" "),s("h3",{attrs:{id:"谈谈你对html5的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对html5的理解"}},[t._v("#")]),t._v(" 谈谈你对HTML5的理解？")]),t._v(" "),s("h3",{attrs:{id:"如何使用一个div里面的文字垂直居中-且该文字的大小根据屏幕大小自适应"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何使用一个div里面的文字垂直居中-且该文字的大小根据屏幕大小自适应"}},[t._v("#")]),t._v(" 如何使用一个div里面的文字垂直居中，且该文字的大小根据屏幕大小自适应？")]),t._v(" "),s("h1",{attrs:{id:"js基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js基础"}},[t._v("#")]),t._v(" js基础")]),t._v(" "),s("h2",{attrs:{id:"数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),s("h3",{attrs:{id:"js判断数组的5种方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js判断数组的5种方式"}},[t._v("#")]),t._v(" JS判断数组的5种方式")]),t._v(" "),s("ul",[s("li",[t._v("instanceof")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" arr isntanceof Array\n")])])]),s("ul",[s("li",[s("p",[s("strong",[t._v("proto")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" arr.__proto__  === Array.prototype\n")])])])]),t._v(" "),s("li",[s("p",[t._v("constructor")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("arr.constructor === Array\n")])])])]),t._v(" "),s("li",[s("p",[t._v("Object.prototype.toString")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 过object类型的副属性class去判断的，其中函数的class是Function，结果是[object Function]， 普通的对象是Object，结果是[object Object]\nObject.prototype.toString.call(arr) === '[object Array]'\n")])])])]),t._v(" "),s("li",[s("p",[t._v("Array.isArray")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// es6新增的方法\nArray.isArray(arr)\n")])])])])]),t._v(" "),s("h3",{attrs:{id:"手写instanceof及原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#手写instanceof及原理"}},[t._v("#")]),t._v(" 手写instanceof及原理")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[s("code",[t._v("instanceof")])]),t._v(" "),s("strong",[t._v("运算符")]),t._v("用于检测构造函数的 "),s("code",[t._v("prototype")]),t._v(" 属性是否出现在某个实例对象的原型链")])]),t._v(" "),s("li",[s("p",[t._v("instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const Person = function() {}\nconst p1 = new Person()\np1 instanceof Person // true\n\nvar str1 = 'hello world'\nstr1 instanceof String // false\n\nvar str2 = new String('hello world')\nstr2 instanceof String // true\n\n// 判断基本数据类型\n// 其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。\nclass PrimitiveNumber {\n  static [Symbol.hasInstance](x) {\n    return typeof x === 'number'\n  }\n}\nconsole.log(111 instanceof PrimitiveNumber) // true\n")])])])])]),t._v(" "),s("h2",{attrs:{id:"异步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[t._v("#")]),t._v(" 异步")]),t._v(" "),s("h3",{attrs:{id:"用settimeout实现setinterval"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用settimeout实现setinterval"}},[t._v("#")]),t._v(" 用setTimeout实现setInterval")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function mySetInterval(fn, millisec,count){\n  function interval(){\n    if(typeof count===‘undefined’||count--\x3e0){\n      setTimeout(interval, millisec);\n      try{\n        fn()\n      }catch(e){\n        count = 0;\n        throw e.toString();\n      }\n    }\n  }\n  setTimeout(interval, millisec)\n}\n")])])]),s("ul",[s("li",[s("p",[t._v("这个"),s("code",[t._v("mySetInterval")]),t._v("函数有一个叫做"),s("code",[t._v("interval")]),t._v("的内部函数，它通过"),s("code",[t._v("setTimeout")]),t._v("来自动被调用，在"),s("code",[t._v("interval")]),t._v("中有一个闭包，调用了回调函数并通过"),s("code",[t._v("setTimeout")]),t._v("再次调用了"),s("code",[t._v("interval")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("增加一个额外的参数用来标明代码执行的次数")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);