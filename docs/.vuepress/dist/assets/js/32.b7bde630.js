(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{354:function(a,e,t){"use strict";t.r(e);var r=t(42),v=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"模块化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[a._v("#")]),a._v(" 模块化")]),a._v(" "),t("h2",{attrs:{id:"import-和-require-导入的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#import-和-require-导入的区别"}},[a._v("#")]),a._v(" import 和 require 导入的区别")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。2.前者编译时输出接口，后者运行时加载。")])]),a._v(" "),t("li",[t("p",[a._v("推荐文章："),t("strong",[a._v("前端模块化：CommonJS,AMD,CMD,ES6")]),a._v("[4]")])]),a._v(" "),t("li",[t("p",[a._v("前端模块化：CommonJS,AMD,CMD,ES6: "),t("em",[a._v("https://juejin.im/post/5aaa37c8f265da23945f365c")])])])]),a._v(" "),t("h3",{attrs:{id:"require-有什么性能问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#require-有什么性能问题"}},[a._v("#")]),a._v(" require 有什么性能问题")]),a._v(" "),t("h2",{attrs:{id:"组件库如何做按需加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件库如何做按需加载"}},[a._v("#")]),a._v(" 组件库如何做按需加载")]),a._v(" "),t("ul",[t("li",[a._v("我常用的是"),t("code",[a._v("babel-plugin-import")])]),a._v(" "),t("li")]),a._v(" "),t("h1",{attrs:{id:"工程化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工程化"}},[a._v("#")]),a._v(" 工程化")]),a._v(" "),t("ol",[t("li",[a._v("webpack怎么优化")]),a._v(" "),t("li",[a._v("happypack和treeshaking作用")]),a._v(" "),t("li",[a._v("项目优化")]),a._v(" "),t("li",[a._v("你做的项目有什么值得说的")])]),a._v(" "),t("h2",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[a._v("#")]),a._v(" Webpack")]),a._v(" "),t("h3",{attrs:{id:"webpack-如何实现动态加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-如何实现动态加载"}},[a._v("#")]),a._v(" webpack 如何实现动态加载")]),a._v(" "),t("ul",[t("li",[a._v("讲道理 webpack 动态加载就两种方式："),t("code",[a._v("import()")]),a._v("和 "),t("code",[a._v("require.ensure")]),a._v("，不过他们实现原理是相同的。")]),a._v(" "),t("li",[a._v("我觉得这道题的重点在于动态的创建 script 标签，以及通过 "),t("code",[a._v("jsonp")]),a._v(" 去请求 "),t("strong",[a._v("chunk")]),a._v("，推荐的文章是："),t("strong",[a._v("webpack 是如何实现动态导入的")]),a._v("[5]")]),a._v(" "),t("li",[a._v("webpack 是如何实现动态导入的: "),t("em",[a._v("https://juejin.im/post/5d26e7d1518825290726f67a")])])]),a._v(" "),t("h3",{attrs:{id:"webpack-能动态加载-require-引入的模块吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-能动态加载-require-引入的模块吗"}},[a._v("#")]),a._v(" webpack 能动态加载 require 引入的模块吗？")]),a._v(" "),t("ul",[t("li",[a._v("应该是不能的，前面说了，webpack 支持动态导入基本上只能用"),t("code",[a._v("import()")]),a._v(" 和"),t("code",[a._v("require.ensure")]),a._v("。")])]),a._v(" "),t("h3",{attrs:{id:"require-引入的模块-webpack-能做-tree-shaking-吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#require-引入的模块-webpack-能做-tree-shaking-吗"}},[a._v("#")]),a._v(" require 引入的模块 webpack 能做 Tree Shaking 吗？")]),a._v(" "),t("ul",[t("li",[a._v("不能，Tree Shaking 需要静态分析，只有 ES6 的模块才支持。")])]),a._v(" "),t("h1",{attrs:{id:"性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[a._v("#")]),a._v(" 性能优化")]),a._v(" "),t("h2",{attrs:{id:"简历里面的性能优化是如何做的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简历里面的性能优化是如何做的"}},[a._v("#")]),a._v(" 简历里面的性能优化是如何做的")]),a._v(" "),t("ul",[t("li",[a._v("减少请求频率、图片压缩、"),t("code",[a._v("React.memo")]),a._v("、"),t("code",[a._v("React.useMemo")])])]),a._v(" "),t("h2",{attrs:{id:"框架性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#框架性能优化"}},[a._v("#")]),a._v(" 框架性能优化")]),a._v(" "),t("h3",{attrs:{id:"如何优化spa应用的首屏加载速度慢的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何优化spa应用的首屏加载速度慢的问题"}},[a._v("#")]),a._v(" 如何优化SPA应用的首屏加载速度慢的问题")]),a._v(" "),t("ul",[t("li",[a._v("将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；")]),a._v(" "),t("li",[a._v("在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；")]),a._v(" "),t("li",[a._v("加一个首屏 loading 图，提升用户体验；")]),a._v(" "),t("li",[a._v("如果在webview中的页面，可以进行页面预加载")]),a._v(" "),t("li",[a._v("独立打包异步组件公共 Bundle，以提高复用性&缓存命中率")]),a._v(" "),t("li",[a._v("静态文件本地缓存，有两种方式分别为HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头和Service Worker离线缓存")]),a._v(" "),t("li",[a._v("配合 PWA 使用")]),a._v(" "),t("li",[a._v("SSR")]),a._v(" "),t("li",[a._v("root中插入loading 或者 骨架屏 prerender-spa-plugin")]),a._v(" "),t("li",[a._v("去掉外链css")]),a._v(" "),t("li",[a._v("http缓存资源 cache-control > expires > etag > last-modified")]),a._v(" "),t("li",[a._v("使用动态 polyfill")]),a._v(" "),t("li",[a._v("使用 SplitChunksPlugin 自动拆分业务基础库，避免加载重复模块")]),a._v(" "),t("li",[a._v("使用 Tree Shaking 减少业务代码体积")]),a._v(" "),t("li",[a._v("懒加载：动态import，loaddable")]),a._v(" "),t("li",[a._v("把代码编译到 ES2015+")]),a._v(" "),t("li",[a._v("使用 lazyload 和 placeholder 提升加载体验")])]),a._v(" "),t("h2",{attrs:{id:"class-组件里面如何做性能优化-因为前面我说了用-react-memo-做了性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class-组件里面如何做性能优化-因为前面我说了用-react-memo-做了性能优化"}},[a._v("#")]),a._v(" class 组件里面如何做性能优化(因为前面我说了用 React.memo 做了性能优化)")]),a._v(" "),t("ul",[t("li",[a._v("shouldComponentUpdate(简称 SCU)。SCU 跟 immutable 强相关，一定要好好理解 react 的 immutable，否则很可能理解不了为什么不能直接去修改 state，然后再去 setState，以及 redux 的 reducer 要返回一个新的对象。")])]),a._v(" "),t("h2",{attrs:{id:"说一下-webpack-的热更新原理吧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一下-webpack-的热更新原理吧"}},[a._v("#")]),a._v(" 说一下 Webpack 的热更新原理吧")]),a._v(" "),t("h2",{attrs:{id:"sourcemap-是什么-有什么作用-生产环境中应该怎么用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sourcemap-是什么-有什么作用-生产环境中应该怎么用"}},[a._v("#")]),a._v(" Sourcemap 是什么？有什么作用？生产环境中应该怎么用？")]),a._v(" "),t("h2",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")])])])}),[],!1,null,null,null);e.default=v.exports}}]);