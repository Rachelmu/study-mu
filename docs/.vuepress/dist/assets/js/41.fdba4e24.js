(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{368:function(t,e,a){"use strict";a.r(e);var r=a(42),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"css"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[t._v("#")]),t._v(" css")]),t._v(" "),a("h3",{attrs:{id:"使用css-让一个div消失在视野中-发挥想象力"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用css-让一个div消失在视野中-发挥想象力"}},[t._v("#")]),t._v(" 使用css，让一个div消失在视野中，发挥想象力？")]),t._v(" "),a("h3",{attrs:{id:"请说明z-index的工作原理-适用范围"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请说明z-index的工作原理-适用范围"}},[t._v("#")]),t._v(" 请说明z-index的工作原理，适用范围？")]),t._v(" "),a("h4",{attrs:{id:"文档流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文档流"}},[t._v("#")]),t._v(" 文档流")]),t._v(" "),a("h4",{attrs:{id:"定位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定位"}},[t._v("#")]),t._v(" 定位")]),t._v(" "),a("h3",{attrs:{id:"border1px问题的形成原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#border1px问题的形成原因"}},[t._v("#")]),t._v(" border1px问题的形成原因")]),t._v(" "),a("h4",{attrs:{id:"产生原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[t._v("#")]),t._v(" 产生原因")]),t._v(" "),a("ul",[a("li",[t._v("设备像素比：dpr=window.devicePixelRatio，也就是设备的物理像素与逻辑像素的比值。像素比 = 物理像素 / css像素")]),t._v(" "),a("li",[t._v("在"),a("code",[t._v("retina")]),t._v("屏的手机上, "),a("code",[t._v("dpr")]),t._v("为"),a("code",[t._v("2")]),t._v("或"),a("code",[t._v("3")]),t._v("，"),a("code",[t._v("css")]),t._v("里写的"),a("code",[t._v("1px")]),t._v("宽度映射到物理像素上就有"),a("code",[t._v("2px")]),t._v("或"),a("code",[t._v("3px")]),t._v("宽度。")]),t._v(" "),a("li",[t._v("例如："),a("code",[t._v("iPhone6")]),t._v("的"),a("code",[t._v("dpr")]),t._v("为"),a("code",[t._v("2")]),t._v("，物理像素是"),a("code",[t._v("750")]),t._v("（x轴）,它的逻辑像素为"),a("code",[t._v("375")]),t._v("。也就是说，1个逻辑像素，在"),a("code",[t._v("x")]),t._v("轴和"),a("code",[t._v("y")]),t._v("轴方向，需要2个物理像素来显示，即：dpr=2时，表示1个CSS像素由4个物理像素点组成。")])]),t._v(" "),a("h4",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),a("h5",{attrs:{id:"_0-5px方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-5px方案"}},[t._v("#")]),t._v(" 0.5px方案")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在"),a("code",[t._v("IOS8+")]),t._v("，苹果系列都已经支持"),a("code",[t._v("0.5px")]),t._v("了，可以借助媒体查询来处理。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/*这是css方式*/\n.border { border: 1px solid #999 }\n@media screen and (-webkit-min-device-pixel-ratio: 2) {\n    .border { border: 0.5px solid #999 }\n}\n/*ios dpr=2和dpr=3情况下border相差无几，下面代码可以省略*/\n@media screen and (-webkit-min-device-pixel-ratio: 3) {\n    .border { border: 0.333333px solid #999 }\n}\n")])])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("IOS7")]),t._v("及以下和"),a("code",[t._v("Android")]),t._v("等其他系统里，"),a("code",[t._v("0.5px")]),t._v("将会被显示为"),a("code",[t._v("0px")]),t._v("。那么我们就需要想出办法解决，说实在一点就是找到"),a("code",[t._v("Hack")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("解决方案是通过"),a("code",[t._v("JavaScript")]),t._v("检测浏览器能否处理"),a("code",[t._v("0.5px")]),t._v("的边框，如果可以，给"),a("code",[t._v("html")]),t._v("标签元素添加个"),a("code",[t._v("class")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if (window.devicePixelRatio && devicePixelRatio >= 2) {\n  var testElem = document.createElement('div');\n  testElem.style.border = '.5px solid transparent';\n  document.body.appendChild(testElem);\n}\nif (testElem.offsetHeight == 1) {\n  document.querySelector('html').classList.add('hairlines');\n}\n  document.body.removeChild(testElem);\n}\n// 脚本应该放在body内，如果在里面运行，需要包装 $(document).ready(function() {})\n")])])])]),t._v(" "),a("li",[a("p",[t._v("然后，极细的边框样式就容易了")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("div {\n  border: 1px solid #bbb;\n}\n.hairlines div {\n  border-width: 0.5px;  \n}\n")])])])]),t._v(" "),a("li",[a("p",[t._v("优点：简单，不需要过多代码。")])]),t._v(" "),a("li",[a("p",[t._v("缺点：无法兼容安卓设备、 "),a("code",[t._v("iOS 7")]),t._v("及以下设备。")])])]),t._v(" "),a("h5",{attrs:{id:"伪类-transform"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#伪类-transform"}},[t._v("#")]),t._v(" 伪类+transform")]),t._v(" "),a("ul",[a("li",[t._v("原理：把原先元素的"),a("code",[t._v("border")]),t._v("去掉，然后利用"),a("code",[t._v(":before")]),t._v("或者"),a("code",[t._v(":after")]),t._v("重做"),a("code",[t._v("border")]),t._v("，并 "),a("code",[t._v("transform")]),t._v("的"),a("code",[t._v("scale")]),t._v("缩小一半，原先的元素相对定位，新做的"),a("code",[t._v("border")]),t._v("绝对定位。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('/*手机端实现真正的一像素边框*/\n.border-1px, .border-bottom-1px, .border-top-1px, .border-left-1px, .border-right-1px {\n    position: relative;\n}\n\n/*线条颜色 黑色*/\n.border-1px::after, .border-bottom-1px::after, .border-top-1px::after, .border-left-1px::after, .border-right-1px::after {\n    background-color: #000;\n}\n\n/*底边边框一像素*/\n.border-bottom-1px::after {\n    content: "";\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    height: 1px;\n    transform-origin: 0 0;\n}\n\n/*上边边框一像素*/\n.border-top-1px::after {\n    content: "";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 1px;\n    transform-origin: 0 0;\n}\n\n/*左边边框一像素*/\n.border-left-1px::after {\n    content: "";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 1px;\n    height: 100%;\n    transform-origin: 0 0;\n}\n\n/*右边边框1像素*/\n.border-right-1px::after {\n    content: "";\n    box-sizing: border-box;\n    position: absolute;\n    right: 0;\n    top: 0;\n    width: 1px;\n    height: 100%;\n    transform-origin: 0 0;\n}\n\n/*边框一像素*/\n.border-1px::after {\n    content: "";\n    box-sizing: border-box;\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    border: 1px solid gray;\n}\n\n\n/*设备像素比*/\n/*显示屏最小dpr为2*/\n@media (-webkit-min-device-pixel-ratio: 2) {\n    .border-bottom-1px::after, .border-top-1px::after {\n        transform: scaleY(0.5);\n    }\n\n    .border-left-1px::after, .border-right-1px::after {\n        transform: scaleX(0.5);\n    }\n\n    .border-1px::after {\n        width: 200%;\n        height: 200%;\n        transform: scale(0.5);\n        transform-origin: 0 0;\n    }\n}\n\n/*设备像素比*/\n@media (-webkit-min-device-pixel-ratio: 3)  {\n    .border-bottom-1px::after, .border-top-1px::after {\n        transform: scaleY(0.333);\n    }\n\n    .border-left-1px::after, .border-right-1px::after {\n        transform: scaleX(0.333);\n    }\n\n    .border-1px::after {\n        width: 300%;\n        height: 300%;\n        transform: scale(0.333);\n        transform-origin: 0 0;\n    }\n}\n/*需要注意<input type="button">是没有:before, :after伪元素的*/\n')])])]),a("ul",[a("li",[t._v("优点：所有场景都能满足，支持圆角(伪类和本体类都需要加border-radius)。")]),t._v(" "),a("li",[t._v("缺点：代码量也很大，对于已经使用伪类的元素(例如clearfix)，可能需要多层嵌套。")])]),t._v(" "),a("h5",{attrs:{id:"viewport-rem"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#viewport-rem"}},[t._v("#")]),t._v(" viewport + rem")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("同时通过设置对应"),a("code",[t._v("viewport")]),t._v("的"),a("code",[t._v("rem")]),t._v("基准值，这种方式就可以像以前一样轻松愉快的写1px了。")])]),t._v(" "),a("li",[a("p",[t._v("在"),a("code",[t._v("devicePixelRatio=2")]),t._v(" 时，设置"),a("code",[t._v("meta")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<meta name="viewport" content="width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">\n')])])])]),t._v(" "),a("li",[a("p",[t._v("在"),a("code",[t._v("devicePixelRatio=3")]),t._v(" 时，设置"),a("code",[t._v("meta")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<meta name="viewport" content="width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no">\n')])])])]),t._v(" "),a("li",[a("p",[t._v("验证")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<!DOCTYPE html>\n<html lang="en">\n<head>\n    <title>移动端1px问题</title>\n    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />\n    <meta name="viewport" id="WebViewport"\n        content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />\n    <style>\n        html {\n            font-size: 11px;\n        }\n        body {\n            padding: 1rem;\n        }\n        * {\n            padding: 0;\n            margin: 0;\n        }\n        .item {\n            padding: 1rem;\n            border-bottom: 1px solid gray;\n            font-size: 1.2rem;\n        }\n    </style>\n    <script>\n        var viewport = document.querySelector("meta[name=viewport]");\n        var dpr = window.devicePixelRatio || 1;\n        var scale = 1 / dpr;\n        //下面是根据设备dpr设置viewport\n        viewport.setAttribute(\n            "content", +\n            "width=device-width," +\n            "initial-scale=" +\n            scale +\n            ", maximum-scale=" +\n            scale +\n            ", minimum-scale=" +\n            scale +\n            ", user-scalable=no"\n        );\n\n        var docEl = document.documentElement;\n        var fontsize = 10 * (docEl.clientWidth / 320) + "px";\n        docEl.style.fontSize = fontsize;\n    <\/script>\n</head>\n<body>\n    <div class="item">border-bottom: 1px solid gray;</div>\n    <div class="item">border-bottom: 1px solid gray;</div>\n</body>\n</html>\n')])])])]),t._v(" "),a("li",[a("p",[t._v("优点：所有场景都能满足，一套代码，可以兼容基本所有布局。")])]),t._v(" "),a("li",[a("p",[t._v("缺点：老项目修改代价过大，只适用于新项目。")])])]),t._v(" "),a("h5",{attrs:{id:"border-image"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#border-image"}},[t._v("#")]),t._v(" border-image")]),t._v(" "),a("h5",{attrs:{id:"background-image"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#background-image"}},[t._v("#")]),t._v(" background-image")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(".background-image-1px {\n  background: url(../img/line.png) repeat-x left bottom;\n  background-size: 100% 1px;\n}\n")])])]),a("ul",[a("li",[t._v("优点：可以设置单条,多条边框，没有性能瓶颈的问题。")]),t._v(" "),a("li",[t._v("缺点：修改颜色麻烦, 需要替换图片；圆角需要特殊处理，并且边缘会模糊。")])]),t._v(" "),a("h5",{attrs:{id:"postcss-write-svg"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#postcss-write-svg"}},[t._v("#")]),t._v(" postcss-write-svg")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用"),a("code",[t._v("border-image")]),t._v("每次都要去调整图片，总是需要成本的。基于上述的原因，我们可以借助于"),a("code",[t._v("PostCSS")]),t._v("的插件"),a("code",[t._v("postcss-write-svg")]),t._v("来帮助我们。如果你的项目中已经有使用"),a("code",[t._v("PostCSS")]),t._v("，那么只需要在项目中安装这个插件。然后在你的代码中使用：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("@svg 1px-border {\n    height: 2px;\n    @rect {\n      fill: var(--color, black);\n      width: 100%;\n      height: 50%;\n    }\n}\n.example {\n    border: 1px solid transparent;\n    border-image: svg(1px-border param(--color #00b1ff)) 2 2 stretch;\n }\n // 编辑出来\n .example {\n    border: 1px solid transparent;\n    border-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E\")\n          2 2 stretch;\n  }\n")])])])])]),t._v(" "),a("h4",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("0.5px")]),t._v("，相信浏览器肯定是会慢慢支持的，目前而言，如果能用的话，可以"),a("code",[t._v("hack")]),t._v("一下。")]),t._v(" "),a("li",[t._v("对于老项目，建议采用"),a("code",[t._v("transform")]),t._v("+伪类。")]),t._v(" "),a("li",[t._v("新项目可以设置"),a("code",[t._v("viewport")]),t._v("的"),a("code",[t._v("scale")]),t._v("值，这个方法兼容性好。")]),t._v(" "),a("li",[a("code",[t._v("postcss-write-svg")]),t._v("简单易用，仅适合直线，圆角建议用"),a("code",[t._v("transform")]),t._v("+伪类实现。")])]),t._v(" "),a("h3",{attrs:{id:"谈谈你对html5的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对html5的理解"}},[t._v("#")]),t._v(" 谈谈你对HTML5的理解？")]),t._v(" "),a("h3",{attrs:{id:"如何使用一个div里面的文字垂直居中-且该文字的大小根据屏幕大小自适应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何使用一个div里面的文字垂直居中-且该文字的大小根据屏幕大小自适应"}},[t._v("#")]),t._v(" 如何使用一个div里面的文字垂直居中，且该文字的大小根据屏幕大小自适应？")]),t._v(" "),a("h3",{attrs:{id:"考察盒子模型和-box-sizing-属性-判断元素的尺寸和颜色。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#考察盒子模型和-box-sizing-属性-判断元素的尺寸和颜色。"}},[t._v("#")]),t._v(" 考察盒子模型和 "),a("code",[t._v("box-sizing")]),t._v(" 属性，判断元素的尺寸和颜色。")]),t._v(" "),a("h3",{attrs:{id:"垂直水平居中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垂直水平居中"}},[t._v("#")]),t._v(" 垂直水平居中")]),t._v(" "),a("ol",[a("li",[t._v("position有哪些属性")]),t._v(" "),a("li",[t._v("less,sass它们的作用是什么")])]),t._v(" "),a("h3",{attrs:{id:"css-优先级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-优先级"}},[t._v("#")]),t._v(" css 优先级")]),t._v(" "),a("ul",[a("li",[t._v("important > 内联 > ID 选择器 > 类选择器 > 标签选择器")])]),t._v(" "),a("h3",{attrs:{id:"避免-css-全局污染。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免-css-全局污染。"}},[t._v("#")]),t._v(" 避免 css 全局污染。")]),t._v(" "),a("ul",[a("li",[t._v("我常用的 css modules")]),t._v(" "),a("li",[t._v("scoped")])]),t._v(" "),a("h4",{attrs:{id:"css-modules-的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-modules-的原理"}},[t._v("#")]),t._v(" css modules 的原理")]),t._v(" "),a("ul",[a("li",[t._v("生成唯一的类名")])]),t._v(" "),a("h3",{attrs:{id:"有一个-a-标签-如何动态的决定他的样式。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有一个-a-标签-如何动态的决定他的样式。"}},[t._v("#")]),t._v(" 有一个 a 标签，如何动态的决定他的样式。")]),t._v(" "),a("ul",[a("li",[t._v("我说了先写几个 css，然后外部传一个前缀的方式。面试官问了都要这样吗？我说可以通过 context 的方式，就不需要每个组件都传了。")])]),t._v(" "),a("h3",{attrs:{id:"用css画一个扇形"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用css画一个扇形"}},[t._v("#")]),t._v(" 用css画一个扇形")]),t._v(" "),a("h2",{attrs:{id:"flex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flex"}},[t._v("#")]),t._v(" flex")]),t._v(" "),a("h3",{attrs:{id:"flex-0-1-auto-是什么意思"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flex-0-1-auto-是什么意思"}},[t._v("#")]),t._v(" "),a("code",[t._v("flex: 0 1 auto;")]),t._v(" 是什么意思？")]),t._v(" "),a("ul",[a("li",[t._v("flex 这个属性常考题，好好把阮老师的那篇 "),a("strong",[t._v("flex 语法篇")]),t._v("[2]看完 flex 的面试题基本没问题。")]),t._v(" "),a("li",[t._v("flex 语法篇: "),a("em",[t._v("https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html")])])]),t._v(" "),a("h2",{attrs:{id:"less"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#less"}},[t._v("#")]),t._v(" less")]),t._v(" "),a("h3",{attrs:{id:"less-的-代表什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#less-的-代表什么"}},[t._v("#")]),t._v(" less 的&代表什么")]),t._v(" "),a("h2",{attrs:{id:"动画"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动画"}},[t._v("#")]),t._v(" 动画")]),t._v(" "),a("h3",{attrs:{id:"动画-补间动画实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动画-补间动画实现"}},[t._v("#")]),t._v(" 动画？补间动画实现")]),t._v(" "),a("ul",[a("li",[t._v("补间动画就是指控制最开始的状态和最末的状态的动画，中间的状态由浏览器自动帮我们计算生成")]),t._v(" "),a("li",[t._v("transition动画最主要的属性是transition属性，它其实是4个属性的缩写。")])]),t._v(" "),a("h1",{attrs:{id:"html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html"}},[t._v("#")]),t._v(" HTML")]),t._v(" "),a("h2",{attrs:{id:"设计一个-input-组件需要哪些属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计一个-input-组件需要哪些属性"}},[t._v("#")]),t._v(" 设计一个 input 组件需要哪些属性")]),t._v(" "),a("ul",[a("li",[t._v("value 、defaultValue、onChange")]),t._v(" "),a("li",[t._v("value 的类型是什么？")]),t._v(" "),a("li",[t._v("onChange 怎么规定 value 的类型")])]),t._v(" "),a("h1",{attrs:{id:"js基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js基础"}},[t._v("#")]),t._v(" js基础")]),t._v(" "),a("h2",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),a("h3",{attrs:{id:"js判断数组的5种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js判断数组的5种方式"}},[t._v("#")]),t._v(" JS判断数组的5种方式")]),t._v(" "),a("ul",[a("li",[t._v("instanceof")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" arr isntanceof Array\n")])])]),a("ul",[a("li",[a("p",[a("strong",[t._v("proto")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" arr.__proto__  === Array.prototype\n")])])])]),t._v(" "),a("li",[a("p",[t._v("constructor")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("arr.constructor === Array\n")])])])]),t._v(" "),a("li",[a("p",[t._v("Object.prototype.toString")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 过object类型的副属性class去判断的，其中函数的class是Function，结果是[object Function]， 普通的对象是Object，结果是[object Object]\nObject.prototype.toString.call(arr) === '[object Array]'\n")])])])]),t._v(" "),a("li",[a("p",[t._v("Array.isArray")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// es6新增的方法\nArray.isArray(arr)\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"手写instanceof及原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写instanceof及原理"}},[t._v("#")]),t._v(" 手写instanceof及原理")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[a("code",[t._v("instanceof")])]),t._v(" "),a("strong",[t._v("运算符")]),t._v("用于检测构造函数的 "),a("code",[t._v("prototype")]),t._v(" 属性是否出现在某个实例对象的原型链")])]),t._v(" "),a("li",[a("p",[t._v("instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const Person = function() {}\nconst p1 = new Person()\np1 instanceof Person // true\n\nvar str1 = 'hello world'\nstr1 instanceof String // false\n\nvar str2 = new String('hello world')\nstr2 instanceof String // true\n\n// 判断基本数据类型\n// 其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。\nclass PrimitiveNumber {\n  static [Symbol.hasInstance](x) {\n    return typeof x === 'number'\n  }\n}\nconsole.log(111 instanceof PrimitiveNumber) // true\n")])])])])]),t._v(" "),a("h2",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("h3",{attrs:{id:"怎么理解闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么理解闭包"}},[t._v("#")]),t._v(" 怎么理解闭包")]),t._v(" "),a("ul",[a("li",[t._v("基础中的基础，虽然社招考得不多，但是如果连闭包都理解不了，应该会减分不少。闭包由于在规范里没有定义，所以很多人下的定义不一样，理解的角度也不同，但是自己要有一套正确的理解方式，如果按照我的理解 JavaScript 里面所有的函数都是闭包，因为有全局环境，所有的函数都可以访问全局变量。")])]),t._v(" "),a("h3",{attrs:{id:"节流和防抖的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节流和防抖的实现"}},[t._v("#")]),t._v(" 节流和防抖的实现")]),t._v(" "),a("ul",[a("li",[t._v("防抖和节流的代码还是需要会手写的，这也是一个闭包的例子，")])]),t._v(" "),a("h2",{attrs:{id:"异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[t._v("#")]),t._v(" 异步")]),t._v(" "),a("h3",{attrs:{id:"用settimeout实现setinterval"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用settimeout实现setinterval"}},[t._v("#")]),t._v(" 用setTimeout实现setInterval")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function mySetInterval(fn, millisec,count){\n  function interval(){\n    if(typeof count===‘undefined’||count--\x3e0){\n      setTimeout(interval, millisec);\n      try{\n        fn()\n      }catch(e){\n        count = 0;\n        throw e.toString();\n      }\n    }\n  }\n  setTimeout(interval, millisec)\n}\n")])])]),a("ul",[a("li",[a("p",[t._v("这个"),a("code",[t._v("mySetInterval")]),t._v("函数有一个叫做"),a("code",[t._v("interval")]),t._v("的内部函数，它通过"),a("code",[t._v("setTimeout")]),t._v("来自动被调用，在"),a("code",[t._v("interval")]),t._v("中有一个闭包，调用了回调函数并通过"),a("code",[t._v("setTimeout")]),t._v("再次调用了"),a("code",[t._v("interval")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("增加一个额外的参数用来标明代码执行的次数")])])]),t._v(" "),a("h3",{attrs:{id:"实现原生ajax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原生ajax"}},[t._v("#")]),t._v(" 实现原生ajax")]),t._v(" "),a("h2",{attrs:{id:"原生js问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生js问题"}},[t._v("#")]),t._v(" 原生js问题")]),t._v(" "),a("h3",{attrs:{id:"for-in-和-for-of的区别详解以及为for-in的输出顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-in-和-for-of的区别详解以及为for-in的输出顺序"}},[t._v("#")]),t._v(" for in 和 for of的区别详解以及为for in的输出顺序")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("都是用来遍历属性")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 例1 遍历对象\nconst obj = {\n        a: 1,\n        b: 2,\n        c: 3\n    }\nfor (let i in obj) {\n    console.log(i)\n    // a\n    // b\n    // c\n}\nfor (let i of obj) {\n    console.log(i)\n    // Uncaught TypeError: obj is not iterable 报错了\n}\n// 例2 遍历数组\nconst arr = ['a', 'b', 'c']\n    // for in 循环\nfor (let i in arr) {\n    console.log(i)\n    // 0\n    // 1\n    // 2\n}\n\n// for of\nfor (let i of arr) {\n    console.log(i)\n    // a\n    // b\n    // c\n}\n// 例3\nconst arr = ['a', 'b']\n// 手动给 arr数组添加一个属性\narr.name = 'qiqingfu'\n\n// for in 循环可以遍历出 name 这个键名\nfor (let i in arr) {\n    console.log(i)\n    // a\n    // b\n    // name\n}\n")])])])]),t._v(" "),a("li",[a("p",[t._v("for in的特点")]),t._v(" "),a("ul",[a("li",[t._v("for ... in 循环返回的值都是数据结构的 键值名。")]),t._v(" "),a("li",[t._v("遍历对象返回的对象的key值,遍历数组返回的数组的下标(key)。")]),t._v(" "),a("li",[t._v("for ... in 循环不仅可以遍历数字键名,还会遍历原型上的值和手动添加的其他键。如——例3")]),t._v(" "),a("li",[t._v("特别情况下, for ... in 循环会以看起来任意的顺序遍历键名")]),t._v(" "),a("li",[a("strong",[t._v("总结一句: for in 循环特别适合遍历对象。")])])])]),t._v(" "),a("li",[a("p",[t._v("for of的特点")]),t._v(" "),a("ul",[a("li",[t._v("for of 循环用来获取一对键值对中的值,而 for in 获取的是 键名")]),t._v(" "),a("li",[t._v("一个数据结构只要部署了 "),a("strong",[t._v("Symbol.iterator")]),t._v(" 属性, 就被视为具有 iterator接口, 就可以使用 for of循环。")]),t._v(" "),a("li",[t._v("例1这个对象,没有 Symbol.iterator这个属性,所以使用 for of会报 obj is not iterable")]),t._v(" "),a("li",[t._v("for of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。")]),t._v(" "),a("li",[t._v("提供了遍历所有数据结构的统一接口")])])]),t._v(" "),a("li",[a("p",[t._v("部署了Symbol。iterator属性的数据结构")]),t._v(" "),a("ul",[a("li",[t._v("只要有 iterator 接口的数据结构,都可以使用 for of循环。\n"),a("ul",[a("li",[t._v("数组 Array")]),t._v(" "),a("li",[t._v("Map")]),t._v(" "),a("li",[t._v("Set")]),t._v(" "),a("li",[t._v("String")]),t._v(" "),a("li",[t._v("arguments对象")]),t._v(" "),a("li",[t._v("Nodelist对象, 就是获取的dom列表集合")])])])])]),t._v(" "),a("li",[a("p",[t._v("以上这些都可以直接使用 for of 循环。凡是部署了 iterator 接口的数据结构也都可以使用数组的 扩展运算符(...)、和解构赋值等操作。")])]),t._v(" "),a("li",[a("p",[t._v("让对象可以使用for of循环")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用 Object.keys() 获取对象的 key值集合后,再使用 for of")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" const obj = {\n        a: 1,\n        b: 2,\n        c: 3\n    }\n\n    for (let i of Object.keys(obj)) {\n        console.log(i)\n        // 1\n        // 2\n        // 3\n    }\n")])])])])])])]),t._v(" "),a("h1",{attrs:{id:"es6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[t._v("#")]),t._v(" ES6")]),t._v(" "),a("h3",{attrs:{id:"let-var-const-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let-var-const-有什么区别"}},[t._v("#")]),t._v(" let var const 有什么区别")]),t._v(" "),a("h3",{attrs:{id:"原型-class-b-继承-class-a-翻译成-es5-应该是什么样子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型-class-b-继承-class-a-翻译成-es5-应该是什么样子"}},[t._v("#")]),t._v(" 原型，class B 继承 class A 翻译成 es5 应该是什么样子")]),t._v(" "),a("ul",[a("li",[t._v("说实话，我觉得这道题其实蛮有水平的，即考察了如何写出一个好的继承方式，也对 new 过程进行了考察，还对考察了对 Class 的理解。")]),t._v(" "),a("li",[t._v("注意的点："),a("code",[t._v("class")]),t._v(" 是有重载功能的，怎么在子类的构造函数里面调用 "),a("code",[t._v("super")])])]),t._v(" "),a("h2",{attrs:{id:"promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),a("h3",{attrs:{id:"手写promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写promise"}},[t._v("#")]),t._v(" 手写Promise")]),t._v(" "),a("h3",{attrs:{id:"手写promise-all"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写promise-all"}},[t._v("#")]),t._v(" 手写Promise.all")]),t._v(" "),a("h3",{attrs:{id:"写一个-promise-重试函数-可以设置时间间隔和次数。function-foo-fn-interval-times"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写一个-promise-重试函数-可以设置时间间隔和次数。function-foo-fn-interval-times"}},[t._v("#")]),t._v(" 写一个 promise 重试函数，可以设置时间间隔和次数。"),a("code",[t._v("function foo(fn, interval, times) {}")])]),t._v(" "),a("h1",{attrs:{id:"dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom"}},[t._v("#")]),t._v(" DOM")]),t._v(" "),a("ol",[a("li",[t._v("cookie有哪些属性")]),t._v(" "),a("li",[t._v("cookie,session,localstorage,sessionstorage有什么区别")]),t._v(" "),a("li",[t._v("怎么禁止js访问cookie")])]),t._v(" "),a("h1",{attrs:{id:"网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[t._v("#")]),t._v(" 网络")]),t._v(" "),a("ol",[a("li",[t._v("简述https原理，以及与http的区别")]),t._v(" "),a("li",[t._v("操作系统中进程和线程怎么通信")]),t._v(" "),a("li",[t._v("你知道哪些http头部")]),t._v(" "),a("li",[t._v("怎么与服务端保持连接")]),t._v(" "),a("li",[t._v("http请求跨域问题，你都知道哪些解决跨域的方法")]),t._v(" "),a("li",[t._v("你了解哪些请求方法，分别有哪些作用和不同")]),t._v(" "),a("li",[t._v("浏览器缓存")]),t._v(" "),a("li",[t._v("jsonp实现一下跨域")]),t._v(" "),a("li",[t._v("你知道哪些状态码")]),t._v(" "),a("li",[t._v("options请求方法有什么用")])]),t._v(" "),a("h2",{attrs:{id:"浏览器缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),a("ul",[a("li",[t._v("浏览器缓存分为"),a("strong",[t._v("强缓存")]),t._v("和"),a("strong",[t._v("协商缓存")]),t._v("，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。")]),t._v(" "),a("li",[t._v("控制强缓存的字段有：Expires 和 Cache-Control，Expires 和 Cache-Control。")]),t._v(" "),a("li",[t._v("控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。")])]),t._v(" "),a("h1",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" VUE")]),t._v(" "),a("ol",[a("li",[t._v("vue-router源码")]),t._v(" "),a("li",[t._v("vue原理（手写代码，实现数据劫持）")]),t._v(" "),a("li",[t._v("Object.defineProperty除了set get外还有什么属性，我回答了configurable enumerable")])]),t._v(" "),a("h2",{attrs:{id:"有用-ssr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有用-ssr"}},[t._v("#")]),t._v(" 有用 ssr")]),t._v(" "),a("h1",{attrs:{id:"react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://react.iamkasong.com/#%E7%AB%A0%E8%8A%82%E8%AF%B4%E6%98%8E",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://react.iamkasong.com/#%E7%AB%A0%E8%8A%82%E8%AF%B4%E6%98%8E"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"react-的基本原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-的基本原理"}},[t._v("#")]),t._v(" react 的基本原理")]),t._v(" "),a("ul",[a("li",[t._v("UI = f(state) ，虚拟 DOM、diff 策略、setState")])]),t._v(" "),a("h2",{attrs:{id:"rreact事件机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rreact事件机制"}},[t._v("#")]),t._v(" Rreact事件机制")]),t._v(" "),a("ul",[a("li",[t._v("一文吃透 React 事件机制原理: "),a("em",[t._v("https://toutiao.io/posts/28of14w/preview")])]),t._v(" "),a("li",[t._v("React 为什么要用合成事件")]),t._v(" "),a("li",[t._v("事件机制：注册和分发的过程。这里面至少要说出事件注册都是在元素的最顶层 "),a("code",[t._v("document")]),t._v(" 节点上。")])]),t._v(" "),a("h2",{attrs:{id:"聊聊-react-的-diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聊聊-react-的-diff"}},[t._v("#")]),t._v(" 聊聊 React 的 diff")]),t._v(" "),a("p",[t._v("聊 diff 建议先看看我之前写过的一篇关于虚拟 DOM 的文章："),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484879&idx=1&sn=ee0d2e3e235fa911ce2878ae2ea2b676&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("从 React 历史的长河里聊虚拟 DOM 及其价值"),a("OutboundLink")],1),t._v("，有助于理解 diff 的意义。")]),t._v(" "),a("p",[t._v("diff 的细节可以看我之前写的："),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484536&idx=1&sn=94777b8c1aab80dffe1fc224bec02c72&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("详解 React 16 的 Diff 策略"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"react-优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-优化"}},[t._v("#")]),t._v(" React 优化")]),t._v(" "),a("p",[t._v("可以看之前我写的 "),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484774&idx=1&sn=9dc58e54a28755504d58bef49a78f3b4&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("React 函数式组件性能优化指南"),a("OutboundLink")],1),t._v("，对于类组件也有对应的 API。")]),t._v(" "),a("h2",{attrs:{id:"聊一聊-react-的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聊一聊-react-的生命周期"}},[t._v("#")]),t._v(" 聊一聊 React 的生命周期")]),t._v(" "),a("ul",[a("li",[t._v("尽量把 React 15 和 16 的进行对比，然后 16 为什么要准备废除那几个生命周期，以及新增的生命周期可以进行替代。")]),t._v(" "),a("li",[t._v("这个图好好的理解一下"),a("img",{attrs:{src:"/Users/mumu/Documents/webExercise/640.jpeg",alt:"640"}})])]),t._v(" "),a("h3",{attrs:{id:"react-16-生命周期有什么改变"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-16-生命周期有什么改变"}},[t._v("#")]),t._v(" react 16 生命周期有什么改变")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("componentWillMount`，`componentWillReceiveProps`，`componentWillUpdate`准备废除，新增了 `static getDerivedStateFromProps` 和 `getSnapshotBeforeUpdate\n")])])]),a("p",[t._v("我还详细的介绍了为什么要用 "),a("code",[t._v("getDerivedStateFromProps")]),t._v(" 来代替即将废除的三个生命周期，主要是 16 版本 render 之前的生命周期可能会被多次执行，具体的可看我的这篇文章："),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484469&idx=1&sn=f68d044f1b0e4e2eb981e3878427b75b&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("Deep In React 之浅谈 React Fiber 架构(一)"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"getderivedstatefromprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getderivedstatefromprops"}},[t._v("#")]),t._v(" getDerivedStateFromProps")]),t._v(" "),a("h2",{attrs:{id:"聊一聊-hooks-怎么处理生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聊一聊-hooks-怎么处理生命周期"}},[t._v("#")]),t._v(" 聊一聊 hooks 怎么处理生命周期")]),t._v(" "),a("ul",[a("li",[t._v("讲道理函数式组件是没有生命周期的，但是如何去模拟类组件的生命周期的作用，都是在 "),a("code",[t._v("useEffect")]),t._v(" 里面进行操作的，因为生命周期里面所做的基本都是副作用，放到 "),a("code",[t._v("useEffect")]),t._v(" 里是最合适的，专门用来处理副作用。")])]),t._v(" "),a("h2",{attrs:{id:"那你聊聊-react-的源码-把你记得起的讲一讲"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#那你聊聊-react-的源码-把你记得起的讲一讲"}},[t._v("#")]),t._v(" 那你聊聊 React 的源码，把你记得起的讲一讲")]),t._v(" "),a("blockquote",[a("p",[t._v("我看过 React 的一部分源码的，所以关于 React 源码更新部分的东西，应该基本都能说个大概。")])]),t._v(" "),a("ul",[a("li",[t._v("FiberNode 有哪些属性")]),t._v(" "),a("li",[t._v("stadeNode 有什么用？")])]),t._v(" "),a("h2",{attrs:{id:"react基础问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react基础问题"}},[t._v("#")]),t._v(" react基础问题")]),t._v(" "),a("h3",{attrs:{id:"react-里有动态加载的-api-吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-里有动态加载的-api-吗"}},[t._v("#")]),t._v(" react 里有动态加载的 api 吗？")]),t._v(" "),a("ul",[a("li",[t._v("React.lazy")])]),t._v(" "),a("h3",{attrs:{id:"react-lazy原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-lazy原理"}},[t._v("#")]),t._v(" React.lazy原理")]),t._v(" "),a("h2",{attrs:{id:"redux-的重点概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-的重点概念"}},[t._v("#")]),t._v(" redux 的重点概念")]),t._v(" "),a("ul",[a("li",[t._v("store、reduce、action、actionCreater、dispatch")]),t._v(" "),a("li",[t._v("状态管理常用的是 redux 和 dva，然后再聊了聊区别已经 redux 的理念")])]),t._v(" "),a("h3",{attrs:{id:"实现一个-redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现一个-redux"}},[t._v("#")]),t._v(" 实现一个 redux")]),t._v(" "),a("ul",[a("li",[t._v("实现 "),a("code",[t._v("createStore")]),t._v(" 的功能，关键点发布订阅的功能，以及取消订阅的功能。")])]),t._v(" "),a("h2",{attrs:{id:"class-组件与函数式组件的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-组件与函数式组件的区别"}},[t._v("#")]),t._v(" class 组件与函数式组件的区别")]),t._v(" "),a("ul",[a("li",[t._v("生命周期、设计理念，感觉这道题比较开发，可以看看 dan 的这篇："),a("strong",[t._v("函数式组件与类组件有何不同？")]),t._v("[3]")]),t._v(" "),a("li",[t._v("函数式组件与类组件有何不同？: "),a("em",[t._v("https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/")])])]),t._v(" "),a("h1",{attrs:{id:"算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),a("ol",[a("li",[t._v("算法：实现36进制转换")]),t._v(" "),a("li",[t._v("树的遍历有几种方式，实现下层次遍历")]),t._v(" "),a("li",[t._v("判断对称二叉树")]),t._v(" "),a("li",[t._v("合并乱序区间")]),t._v(" "),a("li",[t._v("算法题：老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。目标是尽量让更多的孩子满意。如孩子的要求是 1, 3, 5, 4, 2，饼干是1, 1，最多能让1个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是7, 6, 5，最多能让2个孩子满足。")]),t._v(" "),a("li",[t._v("算法题：给定一个正整数数列a, 对于其每个区间, 我们都可以计算一个X值;X值的定义如下: 对于任意区间, 其X值等于区间内最小的那个数乘上区间内所有数和;现在需要你找出数列a的所有区间中, X值最大的那个区间;如数列a为: 3 1 6 4 5 2; 则X值最大的区间为6, 4, 5, X = 4 * (6+4+5) = 60;")]),t._v(" "),a("li",[t._v("算法题：两个有序链表和并成一个有序链表")])]),t._v(" "),a("h3",{attrs:{id:"怎么判断单链表相交。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么判断单链表相交。"}},[t._v("#")]),t._v(" 怎么判断单链表相交。")]),t._v(" "),a("ul",[a("li",[t._v("很多种方法，我当时说的是最后一个节点如果相同，那么就代表相交。")])]),t._v(" "),a("h3",{attrs:{id:"怎么找到第一个相交的节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么找到第一个相交的节点"}},[t._v("#")]),t._v(" 怎么找到第一个相交的节点")]),t._v(" "),a("ul",[a("li",[t._v("同时遍历两个链表到尾部，同时记录两个链表的长度。若两个链表最后的一个节点相同，则两个链表相交。有两个链表的长度后，我们就可以知道哪个链表长，设较长的链表长度为 len1,短的链表长度为 len2。则先让较长的链表向后移动(len1-len2)个长度。然后开始从当前位置同时遍历两个链表，当遍历到的链表的节点相同时，则这个节点就是第一个相交的节点。")]),t._v(" "),a("li",[t._v("这是我刚想到的一种方式，不过当时面试的时候我记得好像更简单，但是想不起来了。")])]),t._v(" "),a("h3",{attrs:{id:"求最大公共前缀"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#求最大公共前缀"}},[t._v("#")]),t._v(" 求最大公共前缀")]),t._v(" "),a("ul",[a("li",[t._v("如 "),a("code",[t._v("['aaafsd', 'aawwewer', 'aaddfff'] => 'aa'")])])]),t._v(" "),a("h1",{attrs:{id:"模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[t._v("#")]),t._v(" 模块化")]),t._v(" "),a("h2",{attrs:{id:"import-和-require-导入的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#import-和-require-导入的区别"}},[t._v("#")]),t._v(" import 和 require 导入的区别")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。2.前者编译时输出接口，后者运行时加载。")])]),t._v(" "),a("li",[a("p",[t._v("推荐文章："),a("strong",[t._v("前端模块化：CommonJS,AMD,CMD,ES6")]),t._v("[4]")])]),t._v(" "),a("li",[a("p",[t._v("前端模块化：CommonJS,AMD,CMD,ES6: "),a("em",[t._v("https://juejin.im/post/5aaa37c8f265da23945f365c")])])])]),t._v(" "),a("h3",{attrs:{id:"require-有什么性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#require-有什么性能问题"}},[t._v("#")]),t._v(" require 有什么性能问题")]),t._v(" "),a("h2",{attrs:{id:"组件库如何做按需加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件库如何做按需加载"}},[t._v("#")]),t._v(" 组件库如何做按需加载")]),t._v(" "),a("ul",[a("li",[t._v("我常用的是"),a("code",[t._v("babel-plugin-import")])]),t._v(" "),a("li")]),t._v(" "),a("h1",{attrs:{id:"工程化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工程化"}},[t._v("#")]),t._v(" 工程化")]),t._v(" "),a("ol",[a("li",[t._v("webpack怎么优化")]),t._v(" "),a("li",[t._v("happypack和treeshaking作用")]),t._v(" "),a("li",[t._v("项目优化")]),t._v(" "),a("li",[t._v("你做的项目有什么值得说的")])]),t._v(" "),a("h2",{attrs:{id:"webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[t._v("#")]),t._v(" Webpack")]),t._v(" "),a("h3",{attrs:{id:"webpack-如何实现动态加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-如何实现动态加载"}},[t._v("#")]),t._v(" webpack 如何实现动态加载")]),t._v(" "),a("ul",[a("li",[t._v("讲道理 webpack 动态加载就两种方式："),a("code",[t._v("import()")]),t._v("和 "),a("code",[t._v("require.ensure")]),t._v("，不过他们实现原理是相同的。")]),t._v(" "),a("li",[t._v("我觉得这道题的重点在于动态的创建 script 标签，以及通过 "),a("code",[t._v("jsonp")]),t._v(" 去请求 "),a("strong",[t._v("chunk")]),t._v("，推荐的文章是："),a("strong",[t._v("webpack 是如何实现动态导入的")]),t._v("[5]")]),t._v(" "),a("li",[t._v("webpack 是如何实现动态导入的: "),a("em",[t._v("https://juejin.im/post/5d26e7d1518825290726f67a")])])]),t._v(" "),a("h3",{attrs:{id:"webpack-能动态加载-require-引入的模块吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-能动态加载-require-引入的模块吗"}},[t._v("#")]),t._v(" webpack 能动态加载 require 引入的模块吗？")]),t._v(" "),a("ul",[a("li",[t._v("应该是不能的，前面说了，webpack 支持动态导入基本上只能用"),a("code",[t._v("import()")]),t._v(" 和"),a("code",[t._v("require.ensure")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"require-引入的模块-webpack-能做-tree-shaking-吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#require-引入的模块-webpack-能做-tree-shaking-吗"}},[t._v("#")]),t._v(" require 引入的模块 webpack 能做 Tree Shaking 吗？")]),t._v(" "),a("ul",[a("li",[t._v("不能，Tree Shaking 需要静态分析，只有 ES6 的模块才支持。")])]),t._v(" "),a("h1",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),a("h2",{attrs:{id:"简历里面的性能优化是如何做的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简历里面的性能优化是如何做的"}},[t._v("#")]),t._v(" 简历里面的性能优化是如何做的")]),t._v(" "),a("ul",[a("li",[t._v("减少请求频率、图片压缩、"),a("code",[t._v("React.memo")]),t._v("、"),a("code",[t._v("React.useMemo")])])]),t._v(" "),a("h2",{attrs:{id:"框架性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#框架性能优化"}},[t._v("#")]),t._v(" 框架性能优化")]),t._v(" "),a("h3",{attrs:{id:"如何优化spa应用的首屏加载速度慢的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何优化spa应用的首屏加载速度慢的问题"}},[t._v("#")]),t._v(" 如何优化SPA应用的首屏加载速度慢的问题")]),t._v(" "),a("ul",[a("li",[t._v("将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；")]),t._v(" "),a("li",[t._v("在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；")]),t._v(" "),a("li",[t._v("加一个首屏 loading 图，提升用户体验；")]),t._v(" "),a("li",[t._v("如果在webview中的页面，可以进行页面预加载")]),t._v(" "),a("li",[t._v("独立打包异步组件公共 Bundle，以提高复用性&缓存命中率")]),t._v(" "),a("li",[t._v("静态文件本地缓存，有两种方式分别为HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头和Service Worker离线缓存")]),t._v(" "),a("li",[t._v("配合 PWA 使用")]),t._v(" "),a("li",[t._v("SSR")]),t._v(" "),a("li",[t._v("root中插入loading 或者 骨架屏 prerender-spa-plugin")]),t._v(" "),a("li",[t._v("去掉外链css")]),t._v(" "),a("li",[t._v("http缓存资源 cache-control > expires > etag > last-modified")]),t._v(" "),a("li",[t._v("使用动态 polyfill")]),t._v(" "),a("li",[t._v("使用 SplitChunksPlugin 自动拆分业务基础库，避免加载重复模块")]),t._v(" "),a("li",[t._v("使用 Tree Shaking 减少业务代码体积")]),t._v(" "),a("li",[t._v("懒加载：动态import，loaddable")]),t._v(" "),a("li",[t._v("把代码编译到 ES2015+")]),t._v(" "),a("li",[t._v("使用 lazyload 和 placeholder 提升加载体验")])]),t._v(" "),a("h2",{attrs:{id:"class-组件里面如何做性能优化-因为前面我说了用-react-memo-做了性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-组件里面如何做性能优化-因为前面我说了用-react-memo-做了性能优化"}},[t._v("#")]),t._v(" class 组件里面如何做性能优化(因为前面我说了用 React.memo 做了性能优化)")]),t._v(" "),a("ul",[a("li",[t._v("shouldComponentUpdate(简称 SCU)。SCU 跟 immutable 强相关，一定要好好理解 react 的 immutable，否则很可能理解不了为什么不能直接去修改 state，然后再去 setState，以及 redux 的 reducer 要返回一个新的对象。")])]),t._v(" "),a("h1",{attrs:{id:"node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[t._v("#")]),t._v(" Node")]),t._v(" "),a("ol",[a("li",[t._v("node中cluster是怎样开启多进程的，并且一个端口可以被多个进程监听吗")]),t._v(" "),a("li",[t._v("你了解node多进程吗")]),t._v(" "),a("li",[t._v("node进程中怎么通信")]),t._v(" "),a("li",[t._v("node可以开启多线程吗")])]),t._v(" "),a("h1",{attrs:{id:"typescript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[t._v("#")]),t._v(" typescript")]),t._v(" "),a("ol",[a("li",[t._v("你觉得typescript和javascript有什么区别")]),t._v(" "),a("li",[t._v("typescript你都用过哪些类型")]),t._v(" "),a("li",[t._v("typescript中type和interface的区别")]),t._v(" "),a("li",[t._v("Ts 有什么优势- 讲道理所有现在在网上能查到的优势都是得益于"),a("strong",[t._v("静态语言")]),t._v("的优势。")])]),t._v(" "),a("h3",{attrs:{id:"实现一个-typescript-里的-pick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现一个-typescript-里的-pick"}},[t._v("#")]),t._v(" 实现一个 Typescript 里的 Pick")]),t._v(" "),a("ul",[a("li",[t._v("type Pick<T, K extends keyof T> = { [P in K]: T[P] }")])]),t._v(" "),a("h3",{attrs:{id:"type-和-interface-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-和-interface-的区别"}},[t._v("#")]),t._v(" type 和 interface 的区别")]),t._v(" "),a("ul",[a("li",[t._v("这是一个高频题，如果考察 TS，这应该是最容易考察的，网上也都能查到相关的资料，但是很可能忽略一个点："),a("strong",[t._v("type 只是一个类型别名，并不会产生类型")]),t._v("。所以其实 type 和 interface 其实不是同一个概念，其实他们俩不应该用来比较的，只是有时候用起来看着类似。")])]),t._v(" "),a("h3",{attrs:{id:"ts-实现一个-redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ts-实现一个-redux"}},[t._v("#")]),t._v(" ts 实现一个 redux")]),t._v(" "),a("h1",{attrs:{id:"笔试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#笔试题"}},[t._v("#")]),t._v(" 笔试题")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const a = { b: 3}\n\nfunction foo(obj) {\n  obj.b = 5\n\n  return obj\n}\n\nconst aa = foo(a)\n\nconsole.log(a.b)\t// 5\n\nconsole.log(aa.b) // 5\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Ofo() {}\n\nfunction Bick() {\n\tthis.name = 'mybick'\n}\n\nvar myBick = new Ofo()\n\nOfo.prototype = new Bick()\n\nvar youbick = new Bick()\n\nconsole.log(myBick.name)\n\nconsole.log(youbick.name)\n")])])]),a("h3",{attrs:{id:"实现一个-fill-函数-不能用循环。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现一个-fill-函数-不能用循环。"}},[t._v("#")]),t._v(" 实现一个 fill 函数，不能用循环。")]),t._v(" "),a("ul",[a("li",[t._v("考察递归")])]),t._v(" "),a("h3",{attrs:{id:"用-es5-实现私有变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用-es5-实现私有变量"}},[t._v("#")]),t._v(" 用 ES5 实现私有变量")]),t._v(" "),a("ul",[a("li",[t._v("考察闭包的使用")])]),t._v(" "),a("h3",{attrs:{id:"手写-并发只能10个"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写-并发只能10个"}},[t._v("#")]),t._v(" 手写：并发只能10个")]),t._v(" "),a("p",[a("strong",[t._v("考虑过 Vue.js、React 这类的框架为什么要用 Virtual DOM 机制吗？")])]),t._v(" "),a("p",[t._v("1、React / Vue.js 之类的框架为什么需要给组件添加 key 属性，其作用是什么？")]),t._v(" "),a("p",[t._v("2、如何判断当前代码是运行在浏览器还是 Node.js 环境中？")]),t._v(" "),a("p",[t._v("3、Sourcemap 是什么？有什么作用？生产环境中应该怎么用？")]),t._v(" "),a("p",[t._v("4、说一下 Webpack 的热更新原理吧")]),t._v(" "),a("p",[t._v("5、简要描述一下什么是消息队列，宏任务和微任务分别又是怎么回事")])])}),[],!1,null,null,null);e.default=s.exports}}]);