(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{368:function(t,a,s){"use strict";s.r(a);var e=s(42),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vue规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue规范"}},[t._v("#")]),t._v(" Vue规范")]),t._v(" "),s("h2",{attrs:{id:"组件名为多个单词"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件名为多个单词"}},[t._v("#")]),t._v(" 组件名为多个单词")]),t._v(" "),s("ul",[s("li",[t._v("在开发中你可能会遇到 不知道给组件怎么取名 的尴尬情况,遵从vue规范,让你给组件起名即 顺畅 又 规范")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("官方文档")]),t._v(" "),s("p",[t._v("组件名应该始终是多个单词的，根组件 App 以及、之类的 Vue 内置组件除外。\n这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。")])]),t._v(" "),s("ul",[s("li",[t._v("可单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)")]),t._v(" "),s("li",[t._v("我们在命名时即可以采用驼峰命名da也可以采用-命名,但建议大家在项目中统一风格只用一种。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("官方文档")]),t._v(" "),s("p",[t._v("单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因")])]),t._v(" "),s("h2",{attrs:{id:"基础组件用-base-app-v-开头"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础组件用-base-app-v-开头"}},[t._v("#")]),t._v(" 基础组件用 Base | App | V 开头")]),t._v(" "),s("ul",[s("li",[t._v("应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。")])]),t._v(" "),s("h2",{attrs:{id:"单例组件用-the开头"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单例组件用-the开头"}},[t._v("#")]),t._v(" 单例组件用 The开头")]),t._v(" "),s("ul",[s("li",[t._v("只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("官方文档")]),t._v(" "),s("p",[t._v("这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。")])]),t._v(" "),s("h2",{attrs:{id:"紧密耦合的子组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#紧密耦合的子组件"}},[t._v("#")]),t._v(" 紧密耦合的子组件")]),t._v(" "),s("ul",[s("li",[t._v("和父组件紧密耦合的子组件应该以父组件名作为前缀命名。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("官方文档")]),t._v(" "),s("p",[t._v("如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。")])]),t._v(" "),s("h2",{attrs:{id:"组件实例书写顺序规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件实例书写顺序规范"}},[t._v("#")]),t._v(" 组件实例书写顺序规范")]),t._v(" "),s("ul",[s("li",[t._v("在我们平常开发中一个组件会调用很多vue实例,由于开发人员的习惯不同这些实例书写顺序也不同,这样无形之中增加了我们的维护成本,下面我们来看看vue推荐的书写顺序")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("vue文件里面js，要按照vue的生命周期来写，最开始是mixins->porps->data->computed->mounted->watch->methods->components，用不到的可以忽略，统一顺序，养成习惯")])]),t._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("点击查看顺序")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1. name\n2. components\n4. directives\n5. filters\n6. extends\n7. minins\n8. props\n9. data\n10. computed\n11. watch\n12. beforeCreate\n13. created\n14. beforeMount\n15. mounted\n16. beforeUpdate\n17. updated\n18. activated`\n19. deactivated\n20. beforeDestroy\n21. destroyed\n22. methods\n")])])])]),t._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("点击查看代码")]),t._v(" "),s("div",{staticClass:"language-vue extra-class"},[s("pre",{pre:!0,attrs:{class:"language-vue"}},[s("code",[t._v("export default{\n\tname: 'test',\n\tmixins: [],\n\tprops: {},\n\tdata(){},\n\tcomputed: {},\n\twatch(){},\n\tcreated(){},\n\tmounted(){},\n\tmethods:{}\n}\n")])])])]),t._v(" "),s("h2",{attrs:{id:"必要规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#必要规则"}},[t._v("#")]),t._v(" 必要规则")]),t._v(" "),s("h2",{attrs:{id:"组件的-data-必须是一个函数。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件的-data-必须是一个函数。"}},[t._v("#")]),t._v(" 组件的 data 必须是一个函数。")]),t._v(" "),s("ul",[s("li",[t._v("当在组件中使用 data property 的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。")])]),t._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"custom-block-title"},[t._v("很严重的问题")]),t._v(" "),s("p",[t._v("当 data 的值是一个对象时，它会在这个组件的所有实例之间共享。")])]),t._v(" "),s("ul",[s("li",[t._v("我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了")])]),t._v(" "),s("h2",{attrs:{id:"prop-定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#prop-定义"}},[t._v("#")]),t._v(" Prop 定义")]),t._v(" "),s("ul",[s("li",[t._v("Prop 定义应该尽量详细")]),t._v(" "),s("li",[t._v("在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。")])]),t._v(" "),s("h2",{attrs:{id:"组件父子通信规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件父子通信规范"}},[t._v("#")]),t._v(" 组件父子通信规范")]),t._v(" "),s("ul",[s("li",[t._v("一个理想的 Vue 应用是 prop 向下传递，事件向上传递的")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。")]),t._v(" "),s("p",[t._v("一个理想的 Vue应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件")])]),t._v(" "),s("h2",{attrs:{id:"总是用-key-配合-v-for"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总是用-key-配合-v-for"}},[t._v("#")]),t._v(" 总是用 key 配合 v-for")]),t._v(" "),s("ul",[s("li",[t._v("在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的对象固化 (object constancy)，也是一种好的做法。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("在更新 DOM 的时候，Vue 将会优化渲染把可能的 DOM 变更降到最低")]),t._v(" "),s("p",[t._v("不要删除仍然会留在 DOM 中的元素。比如你想使用 "),s("code",[t._v("<transition-group>")]),t._v("给列表加过渡动画，或想在被渲染元素是"),s("code",[t._v("<input>")]),t._v('时保持聚焦。在这些情况下，为每一个项目添加一个唯一的键值 (比如 :key="todo.id") 将会让 Vue 知道如何使行为更容易预测。')])]),t._v(" "),s("h2",{attrs:{id:"避免v-if和v-for用在一起"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免v-if和v-for用在一起"}},[t._v("#")]),t._v(" 避免v-if和v-for用在一起")]),t._v(" "),s("ul",[s("li",[t._v("永远不要把 v-if 和 v-for 同时用在同一个元素上。")])]),t._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("点击查看详解")]),t._v(" "),s("p",[t._v("当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级")]),t._v(" "),s("p",[t._v("因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化")]),t._v(" "),s("p",[t._v("可以通过计算属性，解决该问题。也可以通过将 v-if 移动到容器元素，处理该问题。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);