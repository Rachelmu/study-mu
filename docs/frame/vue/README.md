# Vue基础

## Vue规范

### 组件命名
#### 组件名为多个单词
- 在开发中你可能会遇到 不知道给组件怎么取名 的尴尬情况,遵从vue规范,让你给组件起名即 顺畅 又 规范
::: tip 官方文档
组件名应该始终是多个单词的，根组件 App 以及、之类的 Vue 内置组件除外。
这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。
:::
- 可单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)
- 我们在命名时即可以采用驼峰命名da也可以采用-命名,但建议大家在项目中统一风格只用一种。

::: tip 官方文档
单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因
:::

#### 基础组件用 Base | App | V 开头
- 应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。

#### 单例组件用 The开头
- 只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。
::: tip 官方文档
这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。
:::

#### 紧密耦合的子组件
- 和父组件紧密耦合的子组件应该以父组件名作为前缀命名。
::: tip 官方文档
如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。
:::

### 组件实例书写顺序规范
- 在我们平常开发中一个组件会调用很多vue实例,由于开发人员的习惯不同这些实例书写顺序也不同,这样无形之中增加了我们的维护成本,下面我们来看看vue推荐的书写顺序
::: tip 
vue文件里面js，要按照vue的生命周期来写，最开始是mixins->porps->data->computed->mounted->watch->methods->components，用不到的可以忽略，统一顺序，养成习惯
:::
::: details 点击查看顺序
```
1. name
2. components
4. directives
5. filters
6. extends
7. minins
8. props
9. data
10. computed
11. watch
12. beforeCreate
13. created
14. beforeMount
15. mounted
16. beforeUpdate
17. updated
18. activated`
19. deactivated
20. beforeDestroy
21. destroyed
22. methods
```
:::

::: details 点击查看代码
``` vue
export default{
	name: 'test',
	mixins: [],
	props: {},
	data(){},
	computed: {},
	watch(){},
	created(){},
	mounted(){},
	methods:{}
}
```
:::

### 必要规则
#### 组件的 data 必须是一个函数。
- 当在组件中使用 data property 的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。
::: danger 很严重的问题
当 data 的值是一个对象时，它会在这个组件的所有实例之间共享。
:::
- 我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了

#### Prop 定义
- Prop 定义应该尽量详细
- 在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。

#### 组件父子通信规范
- 一个理想的 Vue 应用是 prop 向下传递，事件向上传递的
::: tip
应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。

一个理想的 Vue应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件
:::

#### 总是用 key 配合 v-for
- 在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的对象固化 (object constancy)，也是一种好的做法。
::: tip
在更新 DOM 的时候，Vue 将会优化渲染把可能的 DOM 变更降到最低

不要删除仍然会留在 DOM 中的元素。比如你想使用 ```<transition-group> ```给列表加过渡动画，或想在被渲染元素是``` <input> ```时保持聚焦。在这些情况下，为每一个项目添加一个唯一的键值 (比如 :key="todo.id") 将会让 Vue 知道如何使行为更容易预测。
::: 

#### 避免v-if和v-for用在一起
- 永远不要把 v-if 和 v-for 同时用在同一个元素上。
::: details 点击查看详解

当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级

因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化

可以通过计算属性，解决该问题。也可以通过将 v-if 移动到容器元素，处理该问题。

:::
